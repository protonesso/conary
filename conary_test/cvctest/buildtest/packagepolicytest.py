#
# Copyright (c) SAS Institute Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


from testrunner import testhelp

import bz2
import glob
import itertools
import os
import re
import stat
import subprocess
import sys

from testutils import mock

try:
    from xml.etree import ElementTree as etree
except ImportError:
    from elementtree import ElementTree as etree  # pyflakes=ignore

import conary_test

from conary.lib import digestlib, log, util
from conary_test import rephelp
from conary_test import resources
from conary.deps import deps
from conary.lib.cfgtypes import ParseError
from conary.lib import pydeps
from conary.lib import logger
from conary.local import database
from conary.build import errors, policy, use, packagepolicy, cook
from conary.build import packagerecipe
from conary import files, versions, trove

pythonVer = "%s.%s" % sys.version_info[:2]


# for use in many places...
def mockedSaveArgSet(self, real, s, *args):
    for arg in args:
        if type(arg) in (list, tuple, set):
            s.update(arg)
        else:
            s.add(arg)
    if real:
        real(self, *args)


class BinariesInBindirsTest(rephelp.RepositoryHelper):
    def testBinariesInBindirsTest1(self):
        """
        """
        recipestr1 = """
class BadBinariesInBindirs(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(bindir)s/blah', mode=0644)
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "BadBinariesInBindirs")

        recipestr2 = """
class LtWrappersInBindirs(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.MakeDirs('%(bindir)s')
        self.Run('''
cat > %(destdir)s/usr/bin/badwrapper <<EOF
#! /bin/sh

# hellotest - temporary wrapper script for .libs/hellotest
# Generated by ltmain.sh - GNU libtool 1.5 (1.1220.2.1 2003/04/14 22:48:00)
#
# The hellotest program cannot be directly executed until all the libtool
# libraries that it depends on are installed.
#
# This wrapper script should never be moved out of the build directory.
# If it is, it will not operate correctly.

# Sed substitution that helps us do robust quoting.  It backslashifies
# metacharacters that are still active within double-quoted strings.
EOF
        ''')
        self.SetModes('%(bindir)s/badwrapper', 0755)
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr2, "LtWrappersInBindirs")

    def testBinariesInBindirsTest2(self):
        """
        """
        recipestr1 = """
class GoodBinariesInBindirs(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.addSource('smbumount')
        self.Create('blah', contents = 'test doc')
        self.Install('smbumount', '%(bindir)s/smbumount', mode = 0755)
        self.Install('blah', '%(thisdocdir)s/blah', mode=0644)
"""
        self.buildRecipe(recipestr1, "GoodBinariesInBindirs")


class BadInterpreterPathsTest(rephelp.RepositoryHelper):
    def testBadInterpreterPathsTest1(self):
        """
        """
        recipestr1 = """
class TestBadInterpreterPaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(bindir)s/blah', contents='#!./foo', mode=0755)
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "TestBadInterpreterPaths")
        recipestr2 = """
class TestBadInterpreterPaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(thisdocdir)s/blah', contents='#!./foo', mode=0755)
"""
        self.reset()
        self.buildRecipe(recipestr2, "TestBadInterpreterPaths")

    def testNoInterpreterPathsTest1(self):
        recipestr1 = """
class TestBadInterpreterPaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(bindir)s/blah', contents='''#!
        foo''', mode=0755)
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "TestBadInterpreterPaths")

    def testSymlinkInterpreter(self):
        os.mkdir(self.workDir + '/dir1')
        open(self.workDir + '/dir1/bin1', 'w').close()
        os.chmod(self.workDir + '/dir1/bin1', 0o755)
        os.symlink('bin1', self.workDir + '/dir1/link1')
        os.symlink('dir1', self.workDir + '/dirlink1')

        open(self.workDir + '/bin2', 'w').close()
        os.chmod(self.workDir + '/bin2', 0o755)
        os.symlink('bin2', self.workDir + '/link2')
        recipestr1 = """
class TestBadInterpreterPaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('/bin/prog1', contents='#!%(workDir)s/dirlink1/bin1\\n', mode=0755)
        self.Create('/bin/prog1b', contents='#!%(workDir)s/dirlink1/link1\\n', mode=0755)
        self.Create('/bin/prog2', contents='#!%(workDir)s/link2\\n', mode=0755)
""" % dict(workDir=self.workDir)
        self.buildRecipe(recipestr1, 'TestBadInterpreterPaths')
        self.updatePkg('test:runtime', depCheck=False)
        # Dir symlink was rewritten
        self.assertEqual(open(self.rootDir + '/bin/prog1').read(),
                '#!%s/dir1/bin1\n' % self.workDir)
        self.assertEqual(open(self.rootDir + '/bin/prog1b').read(),
                '#!%s/dir1/link1\n' % self.workDir)
        # File symlink was not
        self.assertEqual(open(self.rootDir + '/bin/prog2').read(),
                '#!%s/link2\n' % self.workDir)


class NonMultilibComponentTest(rephelp.RepositoryHelper):
    def testNonMultilibComponentTest1(self):
        """
        """
        recipestr1 = """
class TestNonMultilibComponent(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('/usr/%(testlib)s/python%(pyver)s/site-packages/foo/foo.py')
        self.Create('/usr/lib/python%(pyver)s/site-packages/foo/bar.py')
        self.FixupMultilibPaths(exceptions = \
                '/usr/lib/.*')
"""
        self.reset()
        # should fail if files are in different places
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "TestNonMultilibComponent",
            macros={'testlib': 'lib64', 'pyver': pythonVer})
        # should succeed if not
        self.buildRecipe(recipestr1, "TestNonMultilibComponent",
                         macros={'testlib': 'lib',
                                 'pyver': pythonVer})
        recipestr2 = """
class TestNonMultilibComponent(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(libdir)s/python%(pyver)s/site-packages/foo/foo.py')
        self.Create('%(libdir)s/python%(pyver)s/site-packages/foo/bar.py')
        self.Create('/usr/lib/debug/usr/lib64/python%(pyver)s/site-packages/bar.py')
"""
        self.buildRecipe(recipestr2, "TestNonMultilibComponent",
                                     macros={'lib': 'lib64',
                                             'pyver': pythonVer})


class NonMultilibDirectoriesTest(rephelp.RepositoryHelper):
    def testNonMultilibDirectoriesTest1(self):
        if not use.Arch.bits32:
            # this test is only relevant on 32-bit platforms
            return
        """
        """
        recipestr1 = """
class TestNonMultilibDirectories(PackageRecipe):
    name = 'testdirs'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('/usr/lib64/blah')
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
                          recipestr1, "TestNonMultilibDirectories")


class ImproperlySharedTest(rephelp.RepositoryHelper):
    def testImproperlySharedTest1(self):
        """
        Make sure that ELF objects in /usr/share get caught
        """
        recipestr = """
class TestImproperlyShared(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Run("echo 'int main(void) { return 0; }' > foo.c")
        self.Make('foo')
        self.Install('foo', '%(datadir)s/foo/')
"""
        self.logFilter.ignore('warning: EnforceSonameBuildRequirements: .*')
        self.logFilter.add()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestImproperlyShared")
        self.logFilter.remove()
        self.logFilter.compare(['error: ImproperlyShared: Architecture-specific file /usr/share/foo/foo in shared data directory'])


class MakeDevicesTest(rephelp.RepositoryHelper):
    def testMakeDevicesTest1(self):
        """
        Make sure that devices can be made
        """
        recipestr1 = """
class TestMakeDevices(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.MakeDevices('/dev/foo', 'b', 1, 2, 'root', 'root')
        r.MakeDevices('/dev/bar', 'b', 1, 3, 'root', 'root', mode=0200)
        r.MakeDevices('/dev/baz', 'b', 1, 4, 'root', 'root', 0222)
"""
        # just make sure it doesn't blow up
        self.build(recipestr1, "TestMakeDevices")


class DanglingSymlinksTest(rephelp.RepositoryHelper):
    def testDanglingSymlinksTestBad(self):
        """
        Make sure that dangling symlinks are caught when appropriate
        """
        recipestr = """
class TestDanglingSymlinks(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Symlink('/foo', '/bar')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestDanglingSymlinks")

    def testDanglingSymlinksTestGood(self):
        """
        Make sure that non-dangling symlinks are not flagged
        """
        recipestr = """
class TestDanglingSymlinks(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.MakeDirs('/real')
        r.Create('/real/bar')
        r.Run('ln -s real %(destdir)s/link')
        r.Symlink('/link/bar', '/foo')
"""
        self.buildRecipe(recipestr, "TestDanglingSymlinks")

    def testDanglingSymlinksTestAutoUserMode(self):
        """
        Make sure that dangling symlinks to usermode become deps
        """
        recipestr = """
class TestDanglingSymlinks(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Symlink('consolehelper', '%(bindir)s/bar')
        r.Symlink('/proc', '/foo/blah')
        r.Symlink('/proc/blah', '/foo/bar')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestDanglingSymlinks")
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trv.getName(), trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            req = str(fileObj.requires())
            if path == '/usr/bin/bar':
                assert(req.find('trove: usermode:runtime') != -1)
        self.resetRepository()

    def testDanglingSymlinksTestFollowCompReq(self):
        """
        Make sure that dangling symlinks that match a component req are allowed
        """
        recipestr = """
class TestDanglingSymlinks(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/lib/bar', mode=0755)
        r.Symlink('/usr/lib/bar', '/usr/bin/bar')
"""
        self.logFilter.add()
        self.logFilter.ignore('warning: reportMissingBuildRequires: .*')
        self.buildRecipe(recipestr, "TestDanglingSymlinks")
        self.logFilter.remove()
        self.logFilter.compare([])


class SymlinkTargetRequiresTest(rephelp.RepositoryHelper):
    def testSymlinkLocalTroveNoFile(self):
        recipestr = r"""
class TestSymlinkTarget(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Symlink('/opt/foo', '/foo')
        r.Symlink('/opt/bar++', '/bar++')
"""
        self.resetRoot()
        self.addComponent('foo:runtime', [('/opt/foo', '')])
        self.addComponent('bar:runtime', [('/opt/bar++', '')])
        self.updatePkg('foo:runtime')
        self.updatePkg('bar:runtime')

        (built, d) = self.buildRecipe(recipestr, "TestSymlinkTarget",
                logBuild=True)

        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None,
                [x for x in built if 'debuginfo' not in x[0]][0])
        trv = repos.getTrove(*nvf[0])
        self.assertEqual(trv.requires,
                deps.ThawDependencySet('4#bar::runtime|4#foo::runtime'))
        nvf = repos.findTrove(None,
                [x for x in built if 'debuginfo' in x[0]][0])
        fileDict = client.getFilesFromTrove(*nvf[0])
        d = bz2.BZ2Decompressor()
        logData = d.decompress( \
                fileDict['/usr/src/debug/buildlogs/test-0-log.bz2'].read())
        self.assertTrue("warning: Suggested buildRequires additions: ['bar:runtime', 'foo:runtime']" in logData)
        self.assertTrue("warning: Requires: 'foo:runtime' does not provide 'file: /opt/foo', so a requirement on the trove itself was used to satisfy dangling symlink: /foo" in logData)
        self.assertTrue("warning: Requires: 'bar:runtime' does not provide 'file: /opt/bar++', so a requirement on the trove itself was used to satisfy dangling symlink: /bar++" in logData)

    def testSymlinkLocalTroveConflictingFile(self):
        recipestr = r"""
class TestSymlinkTarget(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/opt/foo')
        r.Symlink('/opt/foo', '/foo')
"""
        self.resetRoot()
        self.addComponent('foo:runtime', [('/opt/foo', '')])
        self.updatePkg('foo:runtime')

        (built, d) = self.buildRecipe(recipestr, "TestSymlinkTarget")

        repos = self.openRepository()
        nvf = repos.findTrove(None, built[0])
        trv = repos.getTrove(*nvf[0])
        self.assertEqual(trv.requires, deps.ThawDependencySet(''))

    def testSymlinkLocalTroveWithFile(self):
        recipestr = r"""
class TestSymlinkTarget(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Symlink('/bin/foo', '/foo')
"""
        self.resetRoot()
        self.addComponent('foo:runtime', [('/bin/foo', '#!/bin/bash')],
                provides=deps.parseDep('file: /bin/foo'))
        self.addCollection('foo', strongList=['foo:runtime'])
        self.updatePkg('foo')

        (built, d) = self.buildRecipe(recipestr, "TestSymlinkTarget")

        repos = self.openRepository()
        nvf = repos.findTrove(None, built[0])
        trv = repos.getTrove(*nvf[0])
        self.assertEqual(trv.requires, deps.ThawDependencySet('3#/bin/foo'))

    def testSymlinkExplicitTroveReq(self):
        recipestr = r"""
class TestSymlinkTarget(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Requires('foo:runtime', '.*')
        r.Symlink('/bin/foo', '/foo')
"""
        self.resetRoot()
        self.addComponent('foo:runtime', [('/bin/foo', '#!/bin/bash')],
                provides=deps.parseDep('file: /bin/foo'))
        self.addCollection('foo', strongList=['foo:runtime'])
        self.updatePkg('foo')

        (built, d) = self.buildRecipe(recipestr, "TestSymlinkTarget")

        repos = self.openRepository()
        nvf = repos.findTrove(None, built[0])
        trv = repos.getTrove(*nvf[0])

        # even tho there was a trove requirement already, a file requirement
        # was added by SymlinkTargetRequires
        self.assertEqual(trv.requires,
                deps.ThawDependencySet('3#/bin/foo|4#foo::runtime'))

    def testSymlinkExplicitTroveReq2(self):
        recipestr = r"""
class TestSymlinkTarget(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Requires('foo:runtime', '.*')
        r.Symlink('/bin/foo', '/bar/foo')
        # test response to an absolute symlink
        r.RelativeSymlinks(exceptions = '.*')
"""
        self.resetRoot()
        self.addComponent('foo:runtime', [('/bin/foo', '#!/bin/bash')],
                provides=deps.parseDep('file: /bin/foo'))
        self.addCollection('foo', strongList=['foo:runtime'])
        self.updatePkg('foo')

        (built, d) = self.buildRecipe(recipestr, "TestSymlinkTarget")

        repos = self.openRepository()
        nvf = repos.findTrove(None, built[0])
        trv = repos.getTrove(*nvf[0])

        # even tho there was a trove requirement already, a file requirement
        # was added by SymlinkTargetRequires
        self.assertEqual(trv.requires,
                deps.ThawDependencySet('3#/bin/foo|4#foo::runtime'))

    def testSymlinkExplicitTroveReq3(self):
        recipestr = r"""
class TestSymlinkTarget(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Requires('foo:runtime', '.*')
        # make a variation of previous incarnations. this time, don't use a
        # symlink on /
        r.Symlink('/bin/foo', '/bar/foo')
"""
        self.resetRoot()
        self.addComponent('foo:runtime', [('/bin/foo', '#!/bin/bash')],
                provides=deps.parseDep('file: /bin/foo'))
        self.addCollection('foo', strongList=['foo:runtime'])
        self.updatePkg('foo')

        (built, d) = self.buildRecipe(recipestr, "TestSymlinkTarget")

        repos = self.openRepository()
        nvf = repos.findTrove(None, built[0])
        trv = repos.getTrove(*nvf[0])

        # even tho there was a trove requirement already, a file requirement
        # was added by SymlinkTargetRequires
        self.assertEqual(trv.requires,
                deps.ThawDependencySet('3#/bin/foo|4#foo::runtime'))

    def testSymlinkRequiresException(self):
        recipestr = r"""
class TestSymlinkTarget(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Symlink('/bin/foo', '/bar/foo')
        r.Requires(exceptions = '/bar/foo')
"""
        self.resetRoot()
        self.addComponent('foo:runtime', [('/bin/foo', '#!/bin/bash')],
                provides=deps.parseDep('file: /bin/foo'))
        self.addCollection('foo', strongList=['foo:runtime'])
        self.updatePkg('foo')

        err = self.assertRaises(policy.PolicyError,
                self.buildRecipe, recipestr, "TestSymlinkTarget")

        self.assertEqual(str(err), 'Package Policy errors found:\n' \
                'DanglingSymlinks: Dangling symlink: /bar/foo points ' \
                'to non-existant ../bin/foo (/bin/foo)')


class WarnWriteableTest(rephelp.RepositoryHelper):
    def testWarnWriteableTest1(self):
        recipestr = """
class TestWarnWriteable(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Run("touch %(destdir)s/foo; chmod 666 %(destdir)s/foo")
        self.Run("mkdir %(destdir)s/bar; chmod 775 %(destdir)s/bar")
        self.Run("mkdir %(destdir)s/baz; chmod 775 %(destdir)s/baz")
        self.Run("mkdir %(destdir)s/blah")
        self.SetModes("/blah", 0777)
        self.ExcludeDirectories(exceptions='/bar')
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr, "TestWarnWriteable")
        self.logFilter.remove()
        self.logFilter.compare((
            'warning: WarnWriteable: Possibly inappropriately writeable permission 0666 for file /foo',
        ))
        for p in built:
            self.updatePkg(self.workDir, p[0], p[1])
        assert(self.getmode('/foo') & 0o777 == 0o666)
        assert(self.getmode('/blah') & 0o777 == 0o777)
        self.assertRaises(OSError, os.stat, self.workDir + os.sep + '/baz')

    def getmode(self, filename):
        return os.stat(self.workDir + filename)[stat.ST_MODE]


class ExcludeDirectoriesTest(rephelp.RepositoryHelper):
    def testExcludeDirectories(self):
        recipestr = """
class TestExcludeDirectories(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.macros.bam='/bam/'
        r.MakeDirs('/foo', '/bar', '/baz', '/blah')
        r.Ownership('asdf', 'root', '/foo')
        r.Ownership('root', 'asdf', '/bar')
        r.Ownership('asdf', 'asdf', '/baz')
        r.MakeDirs('/ignoreme')
        r.Create('/ignoreme/foo')
        r.Ownership('asdf', 'asdf', '/ignoreme')
        r.MakeDirs('/includeme')
        r.SetModes('/includeme', 0700)
        r.MakeDirs('%(bam)s', mode=0770)
"""
        self.reset()
        self.logFilter.ignore('^\+ (Methods|Building test|changing mode|'
                                    'Cleaning your old build tree|'
                                    'Processing test|creating directory|'
                                    'deleting ).*')
        self.logFilter.ignore('.*path[Ii]d.*')
        trv = self.logCheck(self.build,
            (recipestr, 'TestExcludeDirectories'),
            [x for x in itertools.chain(
              (r'.* ExcludeDirectories: excluding empty directory /blah',),
              (r'.*: not excluding empty directory /baz because of non-root owner',),
              (r'.*: not excluding empty directory /foo because of non-root owner',),
              (r'.*: not excluding empty directory /bar because of non-root group',),
              (r'.*Copying forward metadata to newly built items...',),
            )],
            {'logLevel': log.DEBUG},
            regExp=True)
        repos = self.openRepository()
        paths = []
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'test:runtime', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            paths.append(path)
        self.assertEqual(len(paths), 6)

    def testExcludeDirectoriesSubdirs(self):
        # CNY-1546
        recipestr = """
class TestExcludeDirectoriesSubdirs(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.MakeDirs('/foo/bar/{asdf,fdsa}')
        r.ExcludeDirectories(exceptions = '/foo/bar/.*')
"""
        self.reset()
        trv = self.build(recipestr, "TestExcludeDirectoriesSubdirs")
        repos = self.openRepository()
        paths = []
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'test:runtime', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            paths.append(path)
        assert(len(paths) == 2)


class WarnIgnoredSetuidTest(rephelp.RepositoryHelper):
    def testWarnIgnoredSetuidTest1(self):
        recipestr = """
class TestWarnIgnoredSetuid(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Run("touch %(destdir)s/foo; chmod 04755 %(destdir)s/foo")
        self.Run("touch %(destdir)s/blah")
        self.SetModes("/blah", 04755)
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr, "TestWarnIgnoredSetuid")
        self.logFilter.remove()
        self.logFilter.compare((
            'warning: IgnoredSetuid: file /foo has unpackaged set{u,g}id mode 04755 in filesystem',
        ))


class FilesForDirectoriesTest(rephelp.RepositoryHelper):
    def testFilesForDirectoriesTest1(self):
        """
        """
        recipestr1 = """
class BadFilesForDirectories(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(bindir)s', mode=0755)
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "BadFilesForDirectories")


class ObsoletePathsTest(rephelp.RepositoryHelper):
    def testObsoletePathsTest1(self):
        """
        """
        recipestr1 = """
class BadObsoletePaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        # make the dir and actually put something into it per CNY-1195
        self.MakeDirs('/usr/info', mode=0755)
        self.Create('/usr/info/foo', contents='foo')
        self.Create('/usr/info/blah/bar', contents='bar')
        self.Create('/usr/share/info/test', contents='test')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "BadObsoletePaths")

    def testObsoletePathsTest2(self):
        recipestr1 = """
class BadObsoletePaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        # these files should end up in the foo package (CNY-1679)
        # these paths will be translated twice. once for renaming the obsolete
        # path /usr/info and once for compressing the info files.
        # if any of the translations fail, files will end up in "test:doc"
        self.MakeDirs('/usr/info/blah', mode=0755)
        self.Run('touch %(destdir)s/usr/info/foo', package = 'foo')
        self.Run('touch %(destdir)s/usr/info/bar', package = 'foo')
        self.Run('touch %(destdir)s/usr/info/blah/foo', package = 'foo')
        self.Run('touch %(destdir)s/usr/info/blah/bar', package = 'foo')
"""
        (built, d) = self.buildRecipe(recipestr1, "BadObsoletePaths")
        self.assertEqual(len(built), 1)
        self.assertEqual(built[0][0], 'foo:doc')

    def testObsoletePathsTest3(self):
        recipestr1 = """
class BadObsoletePaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        # these files should end up in the foo package (CNY-1679)
        # we're looking to prove that SetModes followed a PackageSpec through
        # the path translation process
        self.Create('/usr/doc/foo', package = 'foo')
        self.SetModes('/usr/doc/foo', 0755)
"""
        (built, d) = self.buildRecipe(recipestr1, "BadObsoletePaths")

        # first prove the package spec for Create worked.
        self.assertEqual(built[0][0], 'foo:supdoc')

        repos = self.openRepository()
        trvNVF = repos.findTrove(None, built[0])
        trv = repos.getTrove(*trvNVF[0])
        fileInfo = [x for x in trv.iterFileList()][0]

        # prove the name was changed
        self.assertEqual(fileInfo[1], '/usr/share/doc/foo')

        fileObj = repos.getFileVersion(fileInfo[0], fileInfo[2], fileInfo[3])
        # if the SetModes failed to translate, the modeString will be
        # '-rw-r--r--'
        self.assertEqual(fileObj.modeString(), '-rwxr-xr-x')

    def testObsoletePathsTest4(self):
        recipestr1 = """
class BadObsoletePaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        # these files should end up in the foo package (CNY-1679)
        # we're looking to prove that Replace followed a PackageSpec through
        # the path translation process
        self.Create('/usr/doc/foo', package = 'foo', contents = 'foo')
        self.Replace('foo', 'bar', '/usr/doc/foo')
"""
        (built, d) = self.buildRecipe(recipestr1, "BadObsoletePaths")

        # first prove the package spec for Create worked.
        self.assertEqual(built[0][0], 'foo:supdoc')

        repos = self.openRepository()
        trvNVF = repos.findTrove(None, built[0])
        trv = repos.getTrove(*trvNVF[0])
        fileInfo = [x for x in trv.iterFileList()][0]

        # prove the name was changed
        self.assertEqual(fileInfo[1], '/usr/share/doc/foo')

        fileObj = repos.getFileVersion(fileInfo[0], fileInfo[2], fileInfo[3])
        # now compare the hash of the contents. we expected them to be changed
        # from 'foo' to 'bar'. this proves Replace honors PackageSpec
        hash = digestlib.sha1()
        hash.update('bar\n')
        self.assertEqual(hash.digest(), fileObj.contents.sha1())

    def testObsoletePathsTest5(self):
        recipestr1 = """
class BadObsoletePaths(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        # these files should end up in the foo package (CNY-1679)
        # we're looking to prove that Install followed a PackageSpec through
        # the path translation process
        self.Create('foo')
        self.Install('foo', '/usr/info/foo', package = 'foo')
        self.MakeDirs('/usr/info/blah', mode=0755)
"""
        (built, d) = self.buildRecipe(recipestr1, "BadObsoletePaths")
        self.assertEqual(len(built), 1)
        self.assertEqual(built[0][0], 'foo:doc')


class LinkTypeTest(rephelp.RepositoryHelper):
    def testLinkTypeTestConfig(self):
        recipestr1 = """
class BadLinkType(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(sysconfdir)s/config1')
        self.Run('ln %(destdir)s/%(sysconfdir)s/config1 %(destdir)s/%(sysconfdir)s/config2')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "BadLinkType")

    def testLinkTypeTestDevice(self):
        recipestr2 = """
class BadLinkType(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.MakeDirs('/var')
        self.Run('mkfifo %(destdir)s/var/blah')
        self.Run('ln %(destdir)s/var/blah %(destdir)s/var/baz')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr2, "BadLinkType")

    def testLinkTypeException(self):
        recipestr1 = """
class LinkTypeException(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('%(sysconfdir)s/config1')
        self.Run('ln %(destdir)s/%(sysconfdir)s/config1 %(destdir)s/%(sysconfdir)s/config2')
        self.LinkType(exceptions = '.*')
"""
        self.logFilter.add()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, 'LinkTypeException')
        self.logFilter.remove()
        assert('error: LinkType: Config file /etc/config1 has illegal hard links' in self.logFilter.records)
        assert('error: LinkType: Config file /etc/config2 has illegal hard links' in self.logFilter.records)
        assert('warning: LinkType: Exception .*$ for LinkType was not used' in self.logFilter.records)


class LinkCountTest(rephelp.RepositoryHelper):
    def testLinkCountTestCrossDirFail1(self):
        recipestr1 = """
class BadLinkCount(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('/bar/blah')
        self.MakeDirs('/asdf')
        self.Run('ln %(destdir)s/bar/blah %(destdir)s/asdf/baz')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
           recipestr1, "BadLinkCount")

    def testLinkCountTestCrossDirFail2(self):
        recipestr2 = """
class BadLinkCount(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('/bar/blah')
        self.MakeDirs('/asdf/qwerty')
        self.Run('ln %(destdir)s/bar/blah %(destdir)s/asdf/baz')
        self.Run('ln %(destdir)s/bar/blah %(destdir)s/asdf/qwerty/baz')
        # because /asdf not specified, this should still fail between
        # /asdf/baz and /asdf/qwerty/baz
        self.LinkCount(exceptions='/bar/')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
           recipestr2, "BadLinkCount")

    def testLinkCountTestCrossDirGood(self):
        recipestr1 = """
class GoodLinkCount(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('/bar/blah')
        self.MakeDirs('/asdf/qwerty')
        self.Run('ln %(destdir)s/bar/blah %(destdir)s/asdf/baz')
        self.Run('ln %(destdir)s/bar/blah %(destdir)s/asdf/qwerty/baz')
        # do NOT include /bar; it should not be necessary to include it
        # use a list here to test the parsing path not tested in the
        # BadLinkCount test
        # test all forms of passing in the data to test all code paths
        self.LinkCount(exceptions='/asdf/')
        self.LinkCount(exceptions=('/asdf/', '/asdf/'))
        self.LinkCount(exceptions=['/asdf/'])
"""
        self.buildRecipe(recipestr1, "GoodLinkCount")

    def testLinkCountTestCrossSubDirGood(self):
        recipestr1 = """
class GoodLinkCount(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.Create('/base/foo/file')
        self.MakeDirs('/base/bar')
        self.Run('ln %(destdir)s/base/foo/file %(destdir)s/base/bar/baz')
        self.Run('ln %(destdir)s/base/foo/file %(destdir)s/base/baz')
        self.LinkCount(exceptions='/base/')
"""
        self.buildRecipe(recipestr1, "GoodLinkCount")


class ConfigTest(rephelp.RepositoryHelper):
    def testConfigTest1(self):
        recipestr1 = """
class TestConfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(sysconfdir)s/foo')
        self.Create('%(sysconfdir)s/bar', mode=0755)
"""
        self.reset()
        (built, d) = self.buildRecipe(recipestr1, "TestConfig")
        (name, version, flavor) = built[0]
        name = 'test:config'
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        trv = repos.getTrove(name, version, flavor)
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            assert(fileObj.flags.isConfig())
            found += 1
        self.assertEqual(found, 1)
        name = 'test:runtime'
        trv = repos.getTrove(name, version, flavor)
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            # executable config file in :runtime (CNY-1260)
            assert(fileObj.flags.isConfig())
            found += 1
        self.assertEqual(found, 1)

    def testConfigTest2(self):
        recipestr1 = """
class TestConfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        # test literal usage of the keyword "inclusions" for unusedFilters
        self.Create('/foo')
        self.Config(inclusions = '/foo')
        self.Create('/bar')
        self.Create('/baz')
        self.Config(inclusions = ['/bar', '/baz'])
"""
        self.reset()
        (built, d) = self.buildRecipe(recipestr1, "TestConfig")
        (name, version, flavor) = built[0]
        name = 'test:runtime'
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        trv = repos.getTrove(name, version, flavor)
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            assert(fileObj.flags.isConfig())
            found += 1
        self.assertEqual(found, 3)

    def testConfigTest3(self):
        recipestr1 = """
class TestConfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        # test literal usage of the keyword "inclusions" for unusedFilters
        self.Config(inclusions = '/foo')
"""
        self.reset()
        self.logFilter.add()
        self.buildRecipe(recipestr1, "TestConfig")
        self.logFilter.remove()
        self.assertEqual(self.logFilter.records[0],
                'warning: Config: Inclusion ^/foo$ for Config was not used')

        recipestr2 = """
class CorrectedConfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.MakeDirs('%(sysconfdir)s/')
        self.Run('echo -ne foo > %(destdir)s/%(sysconfdir)s/foo')
        self.Run("chmod a-wx %(destdir)s/%(sysconfdir)s/foo")
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr2, "CorrectedConfig")
        self.logFilter.remove()
        self.logFilter.compare(
                ['warning: Config: Inclusion ^/foo$ for Config was not used',
                 'error: No files were found to add to package test',
                 "warning: Config: adding trailing newline to config file "
                     "'/etc/foo'"])
        (name, version, flavor) = built[0]
        name = 'test:config'
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        trv = repos.getTrove(name, version, flavor)
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            assert(fileObj.flags.isConfig())
            found += 1
        self.assertEqual(found, 1)

    def testBinaryConfig(self):
        recipestr = """
class BadConfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.MakeDirs('%(sysconfdir)s/')
        self.Run('echo -ne "\x81" > %(destdir)s/%(sysconfdir)s/bar')
        self.Run('echo -ne "f\\\\0o" > %(destdir)s/%(sysconfdir)s/baz')
"""
        self.logFilter.add()
        self.assertRaises(policy.PolicyError,
                self.buildRecipe, recipestr, "BadConfig")
        self.logFilter.remove()
        self.assertIn("warning: Config: /etc/baz: file contains NULL byte",
            self.logFilter.records)
        self.assertSubstringIn("warning: Config: /etc/bar: 'utf8' codec can't decode byte 0x81",
            self.logFilter.records)
        self.assertSubstringIn("warning: Config: /etc/bar: 'charmap' codec can't decode byte 0x81",
            self.logFilter.records)

    def testBinaryConfigFFFF(self):
        recipestr = """
class BadConfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.MakeDirs('%(sysconfdir)s/')
        self.Run('echo -ne "\\xff" > %(destdir)s/%(sysconfdir)s/bar')
        self.Run('echo -ne "\\xff\\xff\\xff\\xff" > %(destdir)s/%(sysconfdir)s/baz')
"""
        self.logFilter.add()
        self.assertRaises(policy.PolicyError,
                self.buildRecipe, recipestr, "BadConfig")
        self.logFilter.remove()
        self.assertIn("error: Config: /etc/bar: found 0xFF without newline",
            self.logFilter.records)
        self.assertIn("warning: Config: /etc/baz: file contains 0xFFFF sequence",
            self.logFilter.records)
        self.assertSubstringIn(
            "warning: Config: /etc/baz: 'utf8' codec can't decode byte 0xff",
            self.logFilter.records)

    def testWin1252ConfigIsReallyText(self):
        recipestr = """
class WinConfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.MakeDirs('%(sysconfdir)s/')
        # open/close quotes in Windows Code Page 1252...
        r.Run('echo -ne "# \\x93foo\\x94\\n" > %(destdir)s/%(sysconfdir)s/baz')
"""
        self.logFilter.add()
        self.buildRecipe(recipestr, "WinConfig")
        self.logFilter.remove()
        self.assertEqual(len(self.logFilter.records), 1)
        self.assertSubstringIn(
            "warning: Config: /etc/baz: 'utf8' codec can't decode byte 0x93",
            self.logFilter.records)


class InitialContentsTest(rephelp.RepositoryHelper):

    @testhelp.context('initialcontents')
    def testInitialContentsTest1(self):
        recipestr1 = """
class TestInitialContents(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('/etc/foo')
        # ensure that InitialContents overrides Config settings
        self.Config('/etc/foo')
        self.InitialContents('/etc/foo')
        self.Create('%(localstatedir)s/run/trash')
"""
        (built, d) = self.buildRecipe(recipestr1, "TestInitialContents")
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, built[0])
        trv = repos.getTrove(*nvf[0])
        fileList = list(trv.iterFileList())
        fileObjs = repos.getFileVersions([(x[0], x[2], x[3]) for x in fileList])
        for fileInfo, fileObj in zip(fileList, fileObjs):
            self.assertFalse(fileObj.flags.isConfig(), "Expected config to be unset for %s" % fileInfo[1])
            self.assertTrue(fileObj.flags.isInitialContents(), "Expected initialContents for %s" % fileInfo[1])

    @testhelp.context('initialcontents', 'CNY-2578')
    def testInitialContentsTest2(self):
        recipestr1 = """
class TestInitialContents(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        for baseDir in ('run', 'log', 'cache'):
            self.Create('/var/%s/foo' % baseDir)
            # ensure that InitialContents overrides Config settings
            self.Config('/var/%s/foo' % baseDir)
"""
        (built, d) = self.buildRecipe(recipestr1, "TestInitialContents")
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, built[0])
        trv = repos.getTrove(*nvf[0])
        fileList = list(trv.iterFileList())
        fileObjs = repos.getFileVersions([(x[0], x[2], x[3]) for x in fileList])
        for fileInfo, fileObj in zip(fileList, fileObjs):
            self.assertFalse(fileObj.flags.isConfig(), "Expected config to be unset for %s" % fileInfo[1])
            self.assertTrue(fileObj.flags.isInitialContents(), "Expected initialContents for %s" % fileInfo[1])


class TagsTest(rephelp.RepositoryHelper):
    def testTagsTest1(self):
        if not os.path.exists('/etc/conary/tags/x-font'):
            raise testhelp.SkipTestException('/etc/conary/tags/x-font must be on system for this test')
        xFontContents=file('/etc/conary/tags/x-font').read()

        if '/usr/share/X11/fonts' in xFontContents:
            fontPath = '/usr/share/X11/fonts'
        elif '/usr/X11R6/lib/X11/fonts' in xFontContents:
            fontPath = '/usr/X11R6/lib/X11/fonts'
        elif '/usr/share/fonts' in xFontContents:
            fontPath = '/usr/share/fonts'
        else:
            raise testhelp.SkipTestException('cannot find fonts on system')

        recipestr1 = """
class TestTags(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(tagdescriptiondir)s/foo', contents='''
name            Foo
include         /blah/foo
include         /blah/asdf
datasource      args
''')
        self.Create('/blah/foo')
        self.Create('/blah/asdf')
        self.TagSpec('foo', exceptions='/blah/asdf')
        self.Create('/blah/fdsa')
        self.TagSpec('fd-_sa', '/blah/fdsa')
        self.Create('%(tagdescriptiondir)s/blah')
        self.Create('%(taghandlerdir)s/blah', mode=0755)
        self.Create('FONTPATH/asdf')
        self.TagDescription(exceptions='%(tagdescriptiondir)s/blah')
"""
        recipestr1 = recipestr1.replace('FONTPATH', fontPath)

        self.reset()
        self.logFilter.add()

        (built, d) = self.buildRecipe(recipestr1, "TestTags",
                                      logLevel=log.DEBUG)
        self.logFilter.remove()
        # get the record we want, ignore the rest
        self.logFilter.records = [x for x in self.logFilter.records
                                  if 'Tag' in x ]
        for message in (
            '+ TagDescription: conary tag file: /etc/conary/tags/foo',
            '+ TagHandler: conary tag handler: /usr/libexec/conary/tags/blah',
            '+ TagSpec: Foo: /blah/foo',
            '+ TagSpec: x-font: %s/asdf' % fontPath,
            '+ TagSpec: ignoring tag match for Foo: /blah/asdf',
            '+ TagSpec: fd-_sa: /blah/fdsa',
        ):
            assert message in self.logFilter.records

        self.reset()
        recipestr2 = """
class TestTags(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(sysconfdir)s/conary/tags/foo', contents='''
implements      files foo
''')
"""
        self.reset()
        self.assertRaises(ParseError, self.buildRecipe, recipestr2, "TestTags")

        recipestr3 = """
class TestTags(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(sysconfdir)s/conary/tags/foo', contents='''
implements      files foo
datasource      asdf
''')
"""
        self.reset()
        self.assertRaises(ParseError, self.buildRecipe,
            recipestr3, "TestTags")

        recipestr4 = """
class TestTags(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('/foo')
        self.TagSpec('foo ', '/foo')
"""
        self.assertRaises(policy.PolicyError, self.build,
            recipestr4, "TestTags")


    def testTagsTest2(self):
        """ testTagsTest2: Test when tagging a file without the help of any tagdescription """
        recipestr1 = """
class TestTags(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('/blah/foo')
        self.Create('/blah/asdf')
        self.TagSpec('foo', '/blah/')
        self.TagSpec('foo', exceptions='/blah/asdf')
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr1, "TestTags",
                                      logLevel=log.DEBUG)
        self.logFilter.remove()
        assert('+ TagSpec: foo: /blah/foo' in self.logFilter.records)
        assert('+ TagSpec: ignoring tag match for foo: /blah/asdf' in self.logFilter.records)

    def testTagsTest3(self):
        recipestr1 = """
class TestTags(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(tagdescriptiondir)s/foo', contents='''
name            Foo
include         /blah/
datasource      args
''')
        self.Create('%(tagdescriptiondir)s/bar', contents='''
name            Bar
include         /blah/
datasource      args
''')

        self.Create('/blah/foo')
        self.TagSpec('foo', exceptions='/blah/foo')
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr1, "TestTags",
                                      logLevel=log.DEBUG)
        self.logFilter.remove()
        assert('+ TagDescription: conary tag file: /etc/conary/tags/foo' in self.logFilter.records)
        assert('+ TagDescription: conary tag file: /etc/conary/tags/bar' in self.logFilter.records)
        assert('+ TagSpec: ignoring tag match for Foo: /blah/foo' in self.logFilter.records)
        assert('+ TagSpec: Bar: /blah/foo' in self.logFilter.records)

    def testTagsTest4(self):
        recipeStr1 = """
class TagsTest(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create('%(tagdescriptiondir)s/foo', contents='''
name            Foo
include         /foo
include         /bar
datasource      args
''')
        r.Create('/foo')
        r.Create('/bar')
"""
        self.callCount = 0
        realIterTrovesByPath = database.Database.iterTrovesByPath
        def fakeIterTrovesByPath(*args, **kwargs):
            # we only want to count references to the tagfile. this call is
            # used in a lot of places
            if args[1].endswith('/etc/conary/tags/foo'):
                self.callCount += 1
            return realIterTrovesByPath(*args, **kwargs)

        self.mock(database.Database, 'iterTrovesByPath', fakeIterTrovesByPath)
        built, d = self.buildRecipe(recipeStr1, "TagsTest")
        nvf = built[0][0], versions.VersionFromString(built[0][1]), built[0][2]
        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        fileObjs = [repos.getFileVersion(x[0], x[2], x[3]) \
                for x in trv.iterFileList()]
        for fileObj in [x for x in fileObjs if x.tags != ['tagdescription']]:
            self.assertEqual(fileObj.tags, ['foo'])
        # if callCount is 2, it may be because the buildReq results were not
        # cached. it's also possible that iterTrovesByPath was used somewhere
        # other than TagSpec.doProcess
        self.assertEqual(self.callCount, 1)




class TagLocaleTest(rephelp.RepositoryHelper):
    def testLocale(self):
        'CNP-138'
        recipestr = """
class TagLocaleTest(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create('/usr/share/locale/aa/LC_MESSAGES/iso_3166.mo')
        r.Create('/usr/lib/locale/aa_DJ/LC_MESSAGES/SYS_LC_MESSAGES')
        r.Create('/usr/lib/locale/aa_DJ.utf8/LC_MESSAGES/SYS_LC_MESSAGES')
        r.Create('/usr/share/X11/locale/compose.dir/LC_MESSAGES/foo.mo')
        r.Create('/usr/share/X11/locale/iso8859-1/LC_MESSAGES/foo.mo')
        r.Create('/usr/share/X11/locale/koi8-c/LC_MESSAGES/foo.mo')
        r.Create('/usr/share/X11/locale/C/LC_MESSAGES/foo.mo')
        r.Create('/usr/share/locale/zz_ZZ/LC_MESSAGES/foo.mo')
        r.Create('/opt/locale/hh_HH/foo')
        r.Create('/opt/locale/asd.blah@bar/foo')
        r.Create('/opt/locale/ign/foo')
        r.Create('%(debugsrcdir)s/locale/bad_LCL/LC_MESSAGES/foo.mo')
        r.TagLocale(exceptions='.*zz_ZZ.*')
        r.TagLocale(localeExp=r'/opt/locale/(?P<locale>[^/]*)/')
        r.TagLocale(localeExp=(r'wrong',))
        r.ComponentSpec('runtime', '/opt/locale/ign/foo')
        r.ComponentSpec('locale', '.*')
"""
        self.logFilter.add()
        built, d = self.buildRecipe(recipestr, "TagLocaleTest")
        self.logFilter.remove()
        self.logFilter.compare([
            'warning: TagLocale: localeExp "wrong" missing named group "locale"; use "(?P<locale>" to introduce named group',
            'warning: TagLocale: locale "asd.blah@bar" for file /opt/locale/asd.blah@bar/foo includes disallowed characters',
            'warning: TagLocale: locale "ign" for file /opt/locale/ign/foo in non-locale :runtime component, not adding "locale(ign)" tag',
        ])
        nvf = 'test:locale', versions.VersionFromString(built[0][1]), built[0][2]
        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        fileObjs = [repos.getFileVersion(x[0], x[2], x[3]) \
                for x in trv.iterFileList()]
        localeTags = [x.tags for x in fileObjs]
        localeTags = set(x[0] for x in localeTags if x)
        assert('locale(zz_ZZ)' not in localeTags)
        assert('locale(bad_LCL)' not in localeTags)
        assert('locale(aa_DJ.utf8)' not in localeTags)
        assert('locale(compose.dir)' not in localeTags)
        assert('locale(iso8859-1)' not in localeTags)
        assert('locale(koi8-c)' not in localeTags)
        assert('locale(C)' not in localeTags)
        assert('locale(hh_HH)' in localeTags)
        assert('locale(ign)' not in localeTags)
        self.assertEqual(localeTags, set(('locale(aa)', 'locale(aa_DJ)', 'locale(hh_HH)')))

    def testFullFilenameSet(self):
        sys.oldPath = sys.path
        try:
            sys.path[0:0] = self.cfg.policyDirs
            import lang
        finally:
            sys.path = sys.oldPath
        mockRecipe = mock.MockObject()
        mockRecipe._getCapsulePathsForFile._mock.setDefaultReturn(False)
        lp = lang.TagLocale(mockRecipe)
        mock.mockMethod(lp._tagLocale)
        localefilenames = [x.strip() for x in file(resources.get_archive('localefilenames'))]
        for filename in localefilenames:
            lp.doFile(filename)
        localeTags = set(x[0][1] for x in lp._tagLocale._mock.calls)
        self.assertEqual(len(localeTags), 336)



class TransientTest(rephelp.RepositoryHelper):
    'make sure we mark appropriate files as transient'
    @testhelp.context('initialcontents')
    def testTransientTest1(self):
        recipestr1 = """
class TestTransient(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.macros.homedir = '/foo'
        r.Create('/foo/foo.py', contents='''
class foo:
    pass
''', mode=0755)
        r.CompilePython('%(homedir)s')
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr1, "TestTransient",
                                      logLevel=log.DEBUG)
        self.logFilter.remove()
        # get the record we want, ignore the rest
        self.logFilter.records = self.logFilter.records[3:5]
        # Transient file notices are obscuring useful messages
##      self.logFilter.compare((
##          '+ Transient: /foo/foo.pyc',
##          '+ Transient: /foo/foo.pyo',
##      ))

        recipestr2 = """
class BadTransient(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('/foo')
        self.Config('/foo')
        self.Transient('/foo')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr2, "BadTransient")

        recipestr3 = """
class BadTransient(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('/foo')
        self.InitialContents('/foo')
        self.Transient('/foo')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr3, "BadTransient")



class CheckDesktopFilesTest(rephelp.RepositoryHelper):
    def testCheckDesktopFilesGood(self):
        recipestr1 = """
class TestCheckDesktopFiles(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(datadir)s/applications/foo.desktop',
                 contents='Icon=%(datadir)s/foo/foo.png')
        r.Create('%(datadir)s/applications/bar.desktop',
                 contents='Icon=foo.png')
        r.Create('%(datadir)s/applications/baz.desktop',
                 contents='Icon=foo')
        r.Create('%(datadir)s/foo/foo.png')
"""
        self.reset()
        built, d = self.buildRecipe(recipestr1, "TestCheckDesktopFiles")

    def testCheckDesktopFilesBad(self):
        recipestr2 = """
class BadCheckDesktopFiles(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(datadir)s/applications/foo.desktop',
                 contents='Icon=%(datadir)s/foo/foo.png')
"""
        self.reset()
        self.logFilter.add()
        self.buildRecipe(recipestr2, "BadCheckDesktopFiles")
        self.logFilter.remove()
        assert([x for x in self.logFilter.records
                if 'warning: CheckDesktopFiles' in x])

    def testCheckDesktopFilesOk(self):
        recipestr2 = """
class OkCheckDesktopFiles(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(datadir)s/applications/foo.desktop',
                 contents='Icon=')
"""
        self.reset()
        self.buildRecipe(recipestr2, "OkCheckDesktopFiles")


    def testCheckDesktopFilesExcept(self):
        recipestr3 = """
class ExceptCheckDesktopFiles(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(datadir)s/applications/foo.desktop',
                 contents='Icon=%(datadir)s/foo/foo.png')
        r.CheckDesktopFiles(exceptions='%(datadir)s/applications/foo.desktop')
"""
        self.reset()
        built, d = self.buildRecipe(recipestr3, "ExceptCheckDesktopFiles")


class NormalizeLibrarySymlinksTest(rephelp.RepositoryHelper):
    def testNormalizeLibrarySymlinks(self):
        recipestr = r'''
class TestLibrarySymlinks(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('/sbin/ldconfig', mode=0755, contents='\n'.join((
            '#!/bin/sh',
            'mkdir -p %(destdir)s/opt',
            'echo "$@" > %(destdir)s/opt/args',
            'exit 0',
        )))
        r.Create('%(libdir)s/libfoo.so.1')
'''
        (built, d) = self.buildRecipe(recipestr, "TestLibrarySymlinks")

        (name, version, flavor) = built[0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        name = name.replace(':lib', ':runtime')
        trv = repos.getTrove(name, version, flavor)
        found = False
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trv.getName(), trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if path == '/opt/args':
                found = True
        assert(found)

        # now test the cross-compiling case
        recipestr += """
    def isCrossCompiling(self):
        return True
"""

        (built, d) = self.buildRecipe(recipestr, "TestLibrarySymlinks")
        (name, version, flavor) = built[0]
        version = versions.VersionFromString(version)
        name = name.replace(':lib', ':runtime')
        trv = repos.getTrove(name, version, flavor)
        found = False
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trv.getName(), trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if path == '/opt/args':
                found = True
        assert(not found)


class NormalizeInitscriptContentsTest(rephelp.RepositoryHelper):
    def testNormalizeInitscriptContents(self):
        recipestr = r'''
class TestInitscriptContents(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(initdir)s/foo', mode=0755, contents='\n'.join((
            "# chkconfig: 2345 60 40",
            ". /etc/rc.d/init.d/functions",
            "",
        )))
        r.Create('%(bindir)s/foo1', mode=0755, contents='\n'.join((
            "# chkconfig: 2345 60 40",
            ". /etc/rc.d/init.d/functions",
            "",
        )))
        r.Create('/bin/sh', mode=0755, contents='\n'.join((
            "# chkconfig: 2345 60 40",
            ". /etc/rc.d/init.d/functions",
            "",
        )))

        r.Symlink('%(initdir)s/foo', '%(initdir)s/sh')
        r.Symlink('%(bindir)s/foo1', '%(initdir)s/sh1')
        r.Symlink('/bin/sh', '%(initdir)s/sh1')
        # make sure directories do not trigger tracebacks
        r.MakeDirs('%(initdir)s/blah')
'''
        self.reset()
        (built, d) = self.buildRecipe(recipestr, "TestInitscriptContents")

        (name, version, flavor) = built[0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        trv = repos.getTrove(name, version, flavor)
        found = False
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trv.getName(), trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            req = str(fileObj.requires())
            if path == '/etc/init.d/foo':
                assert(req.find('file: /etc/init.d/functions') != -1)
                assert(fileObj.flags.isConfig())
                found = True
        assert(found)

        for p in built:
            self.updatePkg(self.workDir, p[0], p[1], depCheck=False)
        contents = file(self.workDir+'/etc/init.d/foo').read()
        assert('/etc/rc.d/init.d/functions' not in contents)

        self.resetRepository()


class RequireChkconfigTest(rephelp.RepositoryHelper):
    def testRequireChkconfigTest1(self):
        recipestr1 = """
class TestRequireChkconfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(initdir)s/foo', contents='# chkconfig: 2345 60 40',
                    mode=0755)
"""
        (built, d) = self.buildRecipe(recipestr1, "TestRequireChkconfig")

        recipestr2 = """
class BadRequireChkconfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(initdir)s/foo', contents='# foo',
                    mode=0755)
"""
        self.logFilter.add()
        self.buildRecipe(recipestr2, "BadRequireChkconfig")
        self.logFilter.remove()
        self.assertEqual(self.logFilter.records,
                ['warning: RequireChkconfig: initscript /etc/init.d/foo '
                    'must contain chkconfig information before any '
                    'uncommented lines'])

    def testRequireChkconfigNewFormat(self):
        recipestr1 = """
class TestRequireChkconfig(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(initdir)s/foo',
                contents = chr(10).join(('### BEGIN INIT INFO',
                                         '# Required-Start: messagebus',
                                         '# Default-Start: 2 3 4 5',
                                         '# Short-Description: schrodinger',
                                         '# Description: Does something,',
                                         '# or maybe something else.',
                                         '### END INIT INFO')),
                mode=0755)
"""
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr1, "TestRequireChkconfig")
        self.logFilter.remove()
        self.assertEqual(self.logFilter.records, [])


    def testNewlineInChkconfigHeader(self):
        recipestr = """
class NewLinesInChkconfigHeader(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(initdir)s/foo', mode=0755, contents = '''
# Blah

# More blah

# chkconfig: 2345 60 40
''')
"""
        self.buildRecipe(recipestr, 'NewLinesInChkconfigHeader')

class ComponentTest(rephelp.RepositoryHelper):
    def testComponentTest1(self):
        """
        Verify that conary builds multiple packages
        """
        recipestr1 = """
class TestComponent(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/a')
        r.Create('/aa')
        r.Create('/bb')
        r.Create('/b')
        r.Create('/foo')
        r.Create('/fdsa')
        r.ComponentSpec('b:foo', '/b', '/bb')
        r.ComponentSpec('a:bar', '/a', '/aa')
        r.ComponentSpec(':fdsa', '/fdsa')
        r.MakeDirs('%(libdir)s/packaged')
        r.ExcludeDirectories(exceptions='%(libdir)s/packaged')
"""
        self.resetRepository()
        (built, d) = self.buildRecipe(recipestr1, "TestComponent")
        names = [ x[0] for x in built ]
        assert('foo:runtime' in names)
        assert('b:foo' in names)
        assert('a:bar' in names)
        assert('foo:fdsa' in names)
        assert(':lib' not in names)
        self.resetRepository()

    def testComponentPackageSpecOrder(self):
        """
        Verify that specification order is recipe order
        """
        recipestr = """
class TestComponent(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # test ordering with macros
        r.macros.foo = 'foo'
        r.macros.a = 'a'
        r.Create('/a')
        r.ComponentSpec('b:%(foo)s', '/a')
        r.PackageSpec('%(a)s', '/a')

        r.Create('/g')
        r.PackageSpec('g', '/g')
        r.ComponentSpec('h:foo', '/g')
"""
        self.resetRepository()
        (built, d) = self.buildRecipe(recipestr, "TestComponent")
        names = [ x[0] for x in built ]
        assert('b:foo' in names)
        assert('a:runtime' not in names)
        assert('h:foo' not in names)
        # while g:runtime might be desired, it would require a complete
        # refactoring, so it's unlikely; let's enforce the current
        # behavior of g:foo instead
        assert('g:foo' in names)
        self.resetRepository()

    def testComponentPackageSpecDefaultOrder(self):
        """
        Verify that specification defaults are in order
        """
        recipestr = """
class TestComponent(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(testdir)s/foo')
        r.Create('%(sysconfdir)s/config')
        r.Create('/asdf/fdsa')
        r.Create('%(mandir)s/man2/dev.2')
        r.Create('%(thisdocdir)s/README')
        r.Create('%(mandir)s/man1/runtime.1')
        r.Create('/usr/lib/python/site-packages/bar.py')
        r.FixupMultilibPaths(exceptions='/usr/lib/python/site-packages/bar.py')
        r.Create('/usr/lib/perl/vendor_perl/blah.pl')
        r.Create('%(includedir)s/dev.h')
        # devel/devellib/lib split generally is tested elsewhere
        r.Create('/usr/lib/asdf')
        # test overriding :config CNY-1107
        r.Create('%(sysconfdir)s/configfiledatacomponent')
        # test no executable bits in :config by default (CNY-1260)
        r.Create('%(sysconfdir)s/fdsa2', mode=0700)
        r.Create('%(sysconfdir)s/fdsa3', mode=0445)
        r.Create('/asdf/blah')
        r.Config('/asdf/blah')
        r.ComponentSpec('blah', '/asdf/blah',
                                '%(sysconfdir)s/configfiledatacomponent')
        r.Create('%(datadir)s/lib/CNY-1155')
        r.Create('/usr/lib/mono/CNY-1821')
        r.Create('%(prefix)s/lib/gtk-sharp-2.0/CNY-2032.exe')
        r.Create('%(tagdescriptiondir)s/tagdescription')
        r.Create('%(taghandlerdir)s/taghandler', mode=0755)
        r.Create('%(datadir)s/conary/baseclasses/foo.recipe')
        r.Create('/usr/lib/CNY-3143.la')
        r.Create('%(datadir)s/conary/cml/foo.cml')
        r.RemoveNonPackageFiles(exceptions='/usr/lib/CNY-3143.la')
"""
        self.resetRepository()
        self.cfg.configComponent = True
        trv = self.build(recipestr, "TestComponent")
        repos = self.openRepository()
        pathMap = {}
        troveMap = {
            'foo:test': [ '/var/conary/tests/foo' ],
            'foo:config': [ '/etc/config' ],
            'foo:runtime': [ '/asdf/fdsa', '/etc/fdsa2', '/etc/fdsa3',
                             '/etc/conary/tags/tagdescription',
                             '/usr/libexec/conary/tags/taghandler' ],
            'foo:devel': [ '/usr/share/man/man2/dev.2.gz',
                           '/usr/include/dev.h' ],
            'foo:devellib': [ '/usr/lib/CNY-3143.la' ],
            'foo:supdoc': [ '/usr/share/doc/foo-1/README' ],
            'foo:doc': [ '/usr/share/man/man1/runtime.1.gz' ],
            'foo:python': [ '/usr/lib/python/site-packages/bar.py' ],
            'foo:perl': [ '/usr/lib/perl/vendor_perl/blah.pl' ],
            'foo:lib': [ '/usr/lib/asdf' ],
            'foo:blah': [ '/asdf/blah', '/etc/configfiledatacomponent' ],
            'foo:data' : [ '/usr/share/lib/CNY-1155' ],
            'foo:cil' : [ '/usr/lib/gtk-sharp-2.0/CNY-2032.exe',
                          '/usr/lib/mono/CNY-1821' ],
            'foo:cml' : [ '/usr/share/conary/cml/foo.cml' ],
            'foo:recipe' : ['/usr/share/conary/baseclasses/foo.recipe']
        }
        for trovename in list(troveMap.keys()):
            for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trovename, trv.getVersion(), trv.getFlavor(),
                withFiles=True):
                if trovename not in pathMap:
                    pathMap[trovename] = []
                pathMap[trovename].append(path)
        for trovename in list(troveMap.keys()):
            for path in troveMap[trovename]:
                # make sure we find them all
                assert path in pathMap[trovename], '%s missing from %s'%(
                    path, trovename)
            # make sure no extras
            self.assertEqual(len(pathMap[trovename]), len(troveMap[trovename]))
        self.cfg.configComponent = False
        self.resetRepository()



    def testComponentPackageSpecDepLoop(self):
        """
        Verify that component specification dependency loops are reported
        """
        recipestr = """
class TestComponent(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/foo')
"""
        self.resetRepository()
        oldComponentDirs = self.cfg.componentDirs
        self.cfg.componentDirs = list(self.cfg.componentDirs) + [ resources.get_archive('components/') ]
        self.logFilter.add()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestComponent")
        self.logFilter.remove()
        self.logFilter.compare([
            'error: ComponentSpec: dependency loop(s) in component filters: loop2:loop1',
        ])
        self.cfg.componentDirs = oldComponentDirs


    def testPackageSpecBadName(self):
        recipestr = """
class TestPackageSpecBadName(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/a')
        r.PackageSpec('foo/bar', '/a')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestPackageSpecBadName")


class WorldWriteableExecutablesTest(rephelp.RepositoryHelper):
    def testWorldWriteableExecutablesTest1(self):
        recipestr0 = """
class TestWorldWriteableExecutables(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(bindir)s/foo', mode=0777)
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr0, "TestWorldWriteableExecutables")



class FilesInMandirTest(rephelp.RepositoryHelper):
    def testFilesInMandirTest1(self):
        recipestr0 = """
class TestFilesInMandir(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(mandir)s/man1/foo.1')
"""
        self.reset()
        (built, d) = self.buildRecipe(recipestr0, "TestFilesInMandir")
        recipestr1 = """
class TestFilesInMandir(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(mandir)s/foo')
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr1, "TestFilesInMandir")
        recipestr2 = """
class TestFilesInMandir(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(x11prefix)s/man/foo')
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr2, "TestFilesInMandir")
        recipestr3 = """
class TestFilesInMandir(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.Create('%(krbprefix)s/man/foo')
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr3, "TestFilesInMandir")

    def testMandirRename1(self):
        recipestr0 = """
class TestFilesInMandir(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        self.MakeDirs('%(mandir)s/man1')
        self.Run('touch %(destdir)s/%(mandir)s/man1/foo.1', package = 'manpage')
"""
        self.reset()
        (built, d) = self.buildRecipe(recipestr0, "TestFilesInMandir")
        self.assertEqual(built[0][0], 'manpage:doc')

    def testMandirRename2(self):
        recipestr0 = """
class TestFilesInMandir(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        # manual packagespec of the file does not produce a manifest, so this
        # case will not produce a file in manpage:doc
        self.Create('%(mandir)s/man1/foo.1')
        self.PackageSpec('manpage', '%(mandir)s/man1/foo.1')
"""
        self.reset()
        (built, d) = self.buildRecipe(recipestr0, "TestFilesInMandir")
        self.assertEqual(built[0][0], 'test:doc')

    def testMandirRename3(self):
        recipestr0 = """
class TestFilesInMandir(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(self):
        # ensure create manifest works properly.
        self.Create('%(mandir)s/man1/foo.1', package = 'manpage')
"""
        self.reset()
        (built, d) = self.buildRecipe(recipestr0, "TestFilesInMandir")
        self.assertEqual(built[0][0], 'manpage:doc')


class ComponentRequiresTest(rephelp.RepositoryHelper):
    def testComponentRequiresTest1(self):
        """
        Test automatic intra-package intra-component dependencies
        """
        recipestr1 = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/bin/foo', contents='#!/bin/bash', mode=0755)
        r.Create('%(datadir)s/bar', mode=0644)
"""
        self.resetRepository()
        built, d = self.buildRecipe(recipestr1, "TestRequires")
        name, version, flavor = [x for x in built if x[0] == 'foo:runtime'][0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        pkg = repos.getTrove(name, version, flavor)
        # foo:runtime requires foo:data
        assert('foo:data' in str(pkg.getRequires()))
        self.resetRepository()

        recipestr2 = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/bin/foo', contents='#!/bin/bash', mode=0755)
        r.Create('%(datadir)s/bar', mode=0644)
        r.ComponentRequires({'data': frozenset(('lib',))})
"""
        self.resetRepository()
        built, d = self.buildRecipe(recipestr2, "TestRequires")
        name, version, flavor = [x for x in built if x[0] == 'foo:runtime'][0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        pkg = repos.getTrove(name, version, flavor)
        # foo:runtime does not require foo:data
        assert('foo:data' not in str(pkg.requires))
        self.resetRepository()

        recipestr3 = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/bin/foo', contents='#!/bin/bash', mode=0755)
        r.Create('%(datadir)s/bar', mode=0644)
        r.ComponentRequires({'foo': {'data': frozenset(('lib',))}})
"""
        self.resetRepository()
        built, d = self.buildRecipe(recipestr3, "TestRequires")
        name, version, flavor = [x for x in built if x[0] == 'foo:runtime'][0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        pkg = repos.getTrove(name, version, flavor)
        # foo:runtime does not require foo:data
        assert('foo:data' not in str(pkg.requires))
        self.resetRepository()

    def testLibLikeComponentsNoData(self):
        recipeStr = """class TestRequires(PackageRecipe):
        name = 'foo'
        version = '1'
        clearBuildReqs()
        def setup(r):
            for comp in ('cil', 'java', 'perl', 'python', 'ruby'):
                r.Create('/opt/%s' % comp, component = comp)"""

        self.resetRepository()
        built, d = self.buildRecipe(recipeStr, "TestRequires")
        repos = self.openRepository()
        for nvf in built:
            nvf = repos.findTrove(None, nvf)
            trv = repos.getTrove(*nvf[0])
            self.assertEqual(trv.getRequires(), deps.ThawDependencySet(''))

    def testLibLikeComponents(self):
        recipeStr = """class TestRequires(PackageRecipe):
        name = 'foo'
        version = '1'
        clearBuildReqs()
        def setup(r):
            for comp in ('data', 'cil', 'java', 'perl', 'python', 'ruby'):
                r.Create('/opt/%s' % comp, component = comp)"""

        self.resetRepository()
        built, d = self.buildRecipe(recipeStr, "TestRequires")
        repos = self.openRepository()
        for nvf in built:
            if nvf[0].endswith(':data'):
                ref = ''
            else:
                ref = '4#foo::data'
            nvf = repos.findTrove(None, nvf)
            trv = repos.getTrove(*nvf[0])
            self.assertEqual(trv.getRequires(),
                    deps.ThawDependencySet(ref))


class ComponentProvidesTest(rephelp.RepositoryHelper):
    def testComponentProvidesTest1(self):
        """
        Test trove capability flag provision
        """
        recipestr1 = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/bin/foo', contents='#!/bin/bash', mode=0755)
        r.ComponentProvides(('ASDF', 'FD:SA'))
"""
        self.resetRepository()
        built, d = self.buildRecipe(recipestr1, "TestProvides")
        name, version, flavor = [x for x in built if x[0] == 'foo:runtime'][0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        pkg = repos.getTrove(name, version, flavor)
        assert('trove: foo:runtime(ASDF FD:SA)' in str(pkg.getProvides()))
        self.resetRepository()

        recipestr2 = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.macros.asdf = 'ASDF'
        r.Create('/bin/foo', contents='#!/bin/bash', mode=0755)
        r.ComponentProvides('foo', '%(asdf)s')
"""
        built, d = self.buildRecipe(recipestr2, "TestProvides")
        name, version, flavor = [x for x in built if x[0] == 'foo:runtime'][0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        pkg = repos.getTrove(name, version, flavor)
        assert('trove: foo:runtime(ASDF)' in str(pkg.getProvides()))
        self.resetRepository()

        recipestr3 = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/bin/foo', contents='#!/bin/bash', mode=0755)
"""
        built, d = self.buildRecipe(recipestr3, "TestProvides")
        name, version, flavor = [x for x in built if x[0] == 'foo:runtime'][0]
        version = versions.VersionFromString(version)
        repos = self.openRepository()
        pkg = repos.getTrove(name, version, flavor)
        assert('trove: foo:runtime' in str(pkg.getProvides()))
        self.resetRepository()



class RequiresTest(rephelp.RepositoryHelper):
    servletApiRequires = [
        'java.io.BufferedReader',
        'java.io.CharConversionException',
        'java.io.InputStream',
        'java.io.IOException',
        'java.io.OutputStream',
        'java.io.OutputStreamWriter',
        'java.io.PrintWriter',
        'java.io.Serializable',
        'java.io.UnsupportedEncodingException',
        'java.io.Writer',
        'java.lang.Character',
        'java.lang.Class',
        'java.lang.ClassCastException',
        'java.lang.ClassNotFoundException',
        'java.lang.Cloneable',
        'java.lang.CloneNotSupportedException',
        'java.lang.Exception',
        'java.lang.IllegalArgumentException',
        'java.lang.IllegalStateException',
        'java.lang.Integer',
        'java.lang.NoClassDefFoundError',
        'java.lang.NumberFormatException',
        'java.lang.Object',
        'java.lang.reflect.Method',
        'java.lang.RuntimeException',
        'java.lang.String',
        'java.lang.StringBuffer',
        'java.lang.StringIndexOutOfBoundsException',
        'java.lang.System',
        'java.lang.Throwable',
        'java.net.MalformedURLException',
        'java.security.Principal',
        'java.text.MessageFormat',
        'java.util.Enumeration',
        'java.util.EventListener',
        'java.util.EventObject',
        'java.util.Hashtable',
        'java.util.Locale',
        'java.util.Map',
        'java.util.ResourceBundle',
        'java.util.StringTokenizer',
    ]

    servletApiProvides = [
        'javax.servlet.Filter',
        'javax.servlet.FilterChain',
        'javax.servlet.FilterConfig',
        'javax.servlet.GenericServlet',
        'javax.servlet.RequestDispatcher',
        'javax.servlet.Servlet',
        'javax.servlet.ServletConfig',
        'javax.servlet.ServletContext',
        'javax.servlet.ServletContextAttributeEvent',
        'javax.servlet.ServletContextAttributeListener',
        'javax.servlet.ServletContextEvent',
        'javax.servlet.ServletContextListener',
        'javax.servlet.ServletException',
        'javax.servlet.ServletInputStream',
        'javax.servlet.ServletOutputStream',
        'javax.servlet.ServletRequest',
        'javax.servlet.ServletRequestAttributeEvent',
        'javax.servlet.ServletRequestAttributeListener',
        'javax.servlet.ServletRequestEvent',
        'javax.servlet.ServletRequestListener',
        'javax.servlet.ServletRequestWrapper',
        'javax.servlet.ServletResponse',
        'javax.servlet.ServletResponseWrapper',
        'javax.servlet.SingleThreadModel',
        'javax.servlet.UnavailableException',
        'javax.servlet.http.Cookie',
        'javax.servlet.http.HttpServlet',
        'javax.servlet.http.HttpServletRequest',
        'javax.servlet.http.HttpServletRequestWrapper',
        'javax.servlet.http.HttpServletResponse',
        'javax.servlet.http.HttpServletResponseWrapper',
        'javax.servlet.http.HttpSession',
        'javax.servlet.http.HttpSessionActivationListener',
        'javax.servlet.http.HttpSessionAttributeListener',
        'javax.servlet.http.HttpSessionBindingEvent',
        'javax.servlet.http.HttpSessionBindingListener',
        'javax.servlet.http.HttpSessionContext',
        'javax.servlet.http.HttpSessionEvent',
        'javax.servlet.http.HttpSessionListener',
        'javax.servlet.http.HttpUtils',
        'javax.servlet.http.NoBodyOutputStream',
        'javax.servlet.http.NoBodyResponse',
    ]
    def testRequiresTest1(self):
        """
        Test requirements
        """
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.macros.asdf = 'ASDF'
        r.Create('/bin/foo', contents='#!/bin/bash', mode=0755)
        r.Symlink('/bin/foo', '/bin/blah')
        r.Requires('foo:bar', '/bin/')
        r.Requires('asdf:runtime(FDSA %(asdf)s FDSA)', '/bin/blah')
        r.Requires('/a/path', '/bin/blah')
        r.Requires('file: /b/path', '/bin/blah')
        r.Requires('file:runtime', '/bin/blah')
        r.Create('/blah/bar', contents='#!/bin/bash', mode=0644)
        r.Create('/bin/ignoreme', contents='#!/usr/bin/ignored', mode=0755)
        r.Requires(exceptDeps=('%(essentialbindir)s/ignoreme',
                               'file: %(bindir)s/ignored'))
        r.Create('/bin/relativedep', contents='#!no', mode=0755)
        r.BadInterpreterPaths(exceptions='/bin/relativedep')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestRequires")
        repos = self.openRepository()
        foundPaths = []
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            foundPaths.append(path)
            req = str(fileObj.requires()).split('\n')
            if path == '/bin/foo':
                self.assertIn([x for x in req if x.startswith('file: ')][0],
                              ['file: /bin/bash', 'file: /usr/bin/bash'])
                found += 1
            if path == '/bin/blah':
                self.assertIn('trove: asdf:runtime(ASDF FDSA)', req)
                self.assertIn('file: /a/path', req)
                self.assertIn('file: /b/path', req)
                self.assertIn('trove: file:runtime', req)
                found += 1
            elif path == '/blah/bar':
                # not executable, no #! dep
                self.assertEqual(req, [''])
                found += 1
            if path in ('/bin/foo', '/bin/blah'):
                self.assertIn('trove: foo:bar', req)
                found += 1
            elif path == '/bin/ignoreme':
                self.assertNotIn('file: /usr/bin/ignored', req)
                found += 1
            elif path == '/bin/relativedep':
                self.assertNotIn('file: no', req)
                found += 1
        assert(found == 7)
        self.resetRepository()

    def testRequiresTest2(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/blah/foo')
        r.Requires('foo', '/blah/foo')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestRequires")

    def testRequiresTest3(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/blah/foo')
        r.Requires('group-foo', '/blah/foo')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestRequires")

    def testRequiresTest4(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/blah/foo')
        r.Requires('fileset-foo', '/blah/foo')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestRequires")

    def testRequiresTest5(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/blah/foo')
        r.Requires('foo:bar')
"""
        self.assertRaises(errors.CookError, self.buildRecipe,
                          recipestr, "TestRequires")

    def testRequiresTrove1(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/foo')
        r.Requires('bar:runtime', 'foo:runtime')
"""
        self.resetRepository()
        trv = self.build(recipestr, 'TestRequires')

        self.assertEqual(trv.getName(), 'foo:runtime')
        self.assertEqual(trv.requires(),
                deps.ThawDependencySet('4#bar::runtime'))

    def testRequiresTrove2(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/foo')
        r.Requires('bar:runtime', ':runtime')
"""
        self.resetRepository()
        trv = self.build(recipestr, 'TestRequires')

        self.assertEqual(trv.getName(), 'foo:runtime')
        self.assertEqual(trv.requires(),
                deps.ThawDependencySet('4#bar::runtime'))

    def testRequiresTestRequiresProvides(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/blah/foo')
        r.Create('/blah/bar')
        r.Requires('/blah/bar', '/blah/foo')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestRequires")

    def testLinuxAbiProvides(self):
        if 'x86_64' not in str(self.cfg.buildFlavor):
            raise testhelp.SkipTestException('Skip test on x86 arch')

        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # from glibc=/foresight.rpath.org@fl:2-devel/2.12-10-1[~!bootstrap,~!cross is: x86_64]
        # and conary=/foresight.rpath.org@fl:2-devel/2.2.6-1-1[~!bootstrap is: x86_64]
        r.addSource('ld-x86_64-Linux-abi.so')
        r.addSource('misc.so')
        r.Provides('soname: ld-linux-x86-64.so.2(Linux)',
                   '/lib64/ld-linux-x86-64.so.2')
        r.Install('ld-x86_64-Linux-abi.so', '/lib64/ld-linux-x86-64.so.2')
        r.Install('misc.so', '/')
        r.Requires('soname: libfoo(BLAH)', '/misc.so')
"""
        trv = self.build(recipestr, 'TestRequires')

        repos = self.openRepository()
        trvList = repos.getTroves([ ('foo:runtime', trv.getVersion(),
                                                    trv.getFlavor()),
                                    ('foo:lib', trv.getVersion(),
                                                trv.getFlavor()) ])
        requires = str(trvList[0].requires).split('\n')
        provides = str(trvList[1].provides).split('\n')
        assert('Linux' in
               [ x for x in requires if 'ld-linux' in x ][0])
        assert('soname: ELF64/libfoo(BLAH SysV x86_64)' in requires)
        assert('Linux' in
               [ x for x in provides if 'ld-linux' in x ][0])

    def testRequiresTestBadExceptionRegexp(self):
        # cny-3584/cny-3596
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Requires(exceptDeps='soname: libfoo++')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestRequires")

    def testRequiresTestEmptyRequires(self):
        "CNY-1072: traceback with ELF files that have no DT_NEEDED or DT_SONAME entries"
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'req'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.addSource('v10002d.uc', dest='/usr/X11R6/lib/modules/v10002d.uc')
"""
        self.logFilter.add()
        self.logFilter.ignore('warning: reportMissingBuildRequires: .*')
        trv = self.build(recipestr, "TestRequires")
        self.logFilter.remove()
        self.logFilter.compare([])
        repos = self.openRepository()
        req = None
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'req:lib', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if path.endswith('v10002d.uc'):
                req = str(fileObj.requires())
                assert(req == '')
                prov = str(fileObj.provides())
                assert(prov == '')
        assert(req is not None)
        self.resetRepository()


    def testRequiresTestAutoRequiresProvides(self):
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/asdf/foo', mode=0755)
        r.Create('/bin/bar', mode=0755, contents='#!/asdf/foo')
"""
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "TestRequires")

    def testRequiresCIL(self):
        """
        Test CIL requirements
        """
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.addSource('wsdl2.exe', dest='%(libdir)s/mono/2.0/')
        r.addSource('policy.2.4.config',
                    dest='/usr/lib/mono/gac/policy.2.4.art-sharp/0.0.0.0__35e10195dab3c99f/')
        r.addSource('monodis', dest='%(bindir)s/')
"""
        self.resetRepository()
        reportedBuildReqs = set()
        self.mock(packagepolicy.reportMissingBuildRequires, 'updateArgs',
                  lambda *args:
                    mockedSaveArgSet(args[0], None, reportedBuildReqs, *args[1:]))

        self.logFilter.add()
        trv = self.build(recipestr, "TestRequires", logLevel=log.DEBUG)
        self.logFilter.remove()
        assert([x for x in self.logFilter.records
                if 'The following dependencies' in x])
        self.assertEqual(reportedBuildReqs, set(('mono:devel', 'glibc:runtime')))
        troveName = trv.getName().split(':')[0]+':cil'
        repos = self.openRepository()
        foundPaths = []
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            troveName, trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            foundPaths.append(path)
            req = str(fileObj.requires())
            prov = str(fileObj.provides())
            if 'wsdl2' in path:
                assert('CIL: mscorlib(2.0.3600.0)' in req)
                assert('CIL: System(2.0.3600.0)' in req)
                assert('CIL: System.Web.Services(2.0.3600.0)' in req)
                assert('CIL: System.Xml(2.0.3600.0)' in req)
                # let's do this all in the same place, it's cheaper...
                assert('CIL: wsdl2(0.0.0.0)' in prov)
                found += 1
            elif 'policy' in path:
                assert('CIL: art-sharp(2.8.0.0)' in req)
                assert('CIL: art-sharp(2.4.0.0)' in prov)
                found += 1
        assert(found == 2)
        self.resetRepository()

    def testRequiresJavaClass(self):
        """
        Test Java requirements from .class files
        """
        systemJavaDeps = [
            'javax.xml.xpath.XPathExpression',
            'javax.xml.parsers.ParserConfigurationException',
            'javax.xml.xpath.XPathExpressionException', 'org.w3c.dom.Document',
            'gnu.xml.dom.JAXPFactory', 'gnu.xml.xpath.Expr',
            'javax.xml.parsers.DocumentBuilder', 'org.xml.sax.SAXException',
            'java.util.Collection', 'java.lang.String', 'org.w3c.dom.Element',
            'org.xml.sax.InputSource', 'java.util.StringTokenizer',
            'java.util.List', 'javax.xml.parsers.DocumentBuilderFactory',
            'java.lang.Throwable', 'java.util.Comparator',
            'java.text.DecimalFormatSymbols', 'java.util.Set',
            'javax.xml.namespace.QName', 'java.text.DecimalFormat',
            'org.w3c.dom.Node', 'java.util.Iterator', 'java.lang.Boolean',
            'java.util.Locale', 'java.util.ArrayList',
            'javax.xml.xpath.XPathConstants', 'java.lang.Object',
            'java.lang.Double', 'java.util.Collections',
            'java.text.NumberFormat', 'java.util.HashSet',
            'java.lang.IllegalArgumentException',
            'java.lang.NumberFormatException', 'java.lang.StringBuffer',
            'gnu.xml.xpath.DocumentOrderComparator', 'java.io.IOException',
            'javax.servlet.ServletResponse', 'javax.servlet.FilterConfig',
            'javax.servlet.FilterChain', 'javax.servlet.Filter',
            'javax.servlet.ServletRequest', 'javax.servlet.ServletException',
            'java.security.InvalidKeyException', 'java.lang.RuntimeException',
        ]
        provides = deps.DependencySet()
        for d in systemJavaDeps:
            provides.addDep(deps.JavaDependencies, deps.Dependency(d, []))
        self.addComponent('fake-jre:runtime', '1', provides = provides)
        self.updatePkg('fake-jre:runtime')
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.addSource('SetCharacterEncodingFilter.class', dest='/foo/')
        # this second merely ensures that double-length (double or long)
        # symbol table entries do not break symbol table parsing
        r.addSource('Expr.class', dest='/foo/')
        # this third merely ensures that arrays in symbol tables are
        # ignored in dependencies
        r.addSource('SunJCE_e.class', dest='/foo/')
"""
        self.resetRepository()
        # Test EnforceJavaBuildRequirements here instead of duplicating tests
        self.logFilter.add()
        trv = self.build(recipestr, "TestRequires", logLevel=log.DEBUG)
        self.logFilter.remove()
        # CNY-2175: files with unsolved deps get their provides and requires
        # dropped. This means EnforceJavaBuildRequirements is changing its
        # meaning.
        #assert([x for x in self.logFilter.records
        #        if 'The following dependencies' in x])
        self.assertIn('warning: EnforceJavaBuildRequirements: buildRequires [\'fake-jre:runtime\'] needed to satisfy "java: javax.servlet.Filter" for files: /foo/SetCharacterEncodingFilter.class',
            self.logFilter.records)
        self.assertIn("warning: Provides: Provides and requirements for file /foo/SunJCE_e.class are disabled because of unsatisfied dependencies. To re-enable them, add to the recipe's buildRequires the packages that provide the following requirements: com.sun.crypto.provider.SunJCE_f com.sun.crypto.provider.SunJCE_g",
            self.logFilter.records)
        troveName = trv.getName().split(':')[0]+':runtime'
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            troveName, trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            prov = str(fileObj.provides())
            if path == '/foo/SunJCE_e.class':
                # This class has incomplete dependencies (SUNJCE_f and
                # SUNJCE_g), its provides and requires are dropped
                self.assertFalse(req)
                self.assertFalse(prov)
                continue
            # CNY-2177 mandates that files should not require self provides
            if path == '/foo/Expr.class':
                self.assertEqual(prov, 'java: gnu.xml.xpath.Expr')
                self.assertFalse('java: gnu.xml.xpath.Expr' in req)
                continue
            if path != '/foo/SetCharacterEncodingFilter.class':
                self.fail("Unexpected path %s" % path)
            self.assertFalse('java: filters.SetCharacterEncodingFilter' in req)
            self.assertIn('java: java.io.IOException', req)
            self.assertIn('java: java.lang.Object', req)
            self.assertIn('java: java.lang.String', req)
            self.assertIn('java: javax.servlet.Filter', req)
            self.assertIn('java: javax.servlet.FilterChain', req)
            self.assertIn('java: javax.servlet.FilterConfig', req)
            self.assertIn('java: javax.servlet.ServletException', req)
            self.assertIn('java: javax.servlet.ServletRequest', req)
            self.assertIn('java: javax.servlet.ServletResponse', req)
            # let's do provides and requires in the same place, it's cheaper...
            assert('java: filters.SetCharacterEncodingFilter' in prov)
        self.resetRepository()

    def testRequiresJavaJar(self):
        """
        Test Java requirements from .jar files
        """

        provides = deps.DependencySet()
        for d in self.servletApiRequires:
            provides.addDep(deps.JavaDependencies, deps.Dependency(d, []))
        self.addComponent('fake-jre:runtime', '1', provides = provides)
        self.updatePkg('fake-jre:runtime')
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.addSource('servlet-api.jar', dest='/foo/')
        r.addSource('broken.jar', dest='/bar/')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestRequires")
        troveName = trv.getName().split(':')[0]+':java'
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            troveName, trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            prov = str(fileObj.provides())
            if path == '/bar/broken.jar':
                self.assertEqual(req, '')
                self.assertEqual(prov, '')
                continue
            if path != '/foo/servlet-api.jar':
                self.fail("Unexpected path %s" % path)
            # lots of requirements in this jar
            # CNY-2177 mandates that files should not require self provides
            sreq = '\n'.join('java: ' + x
                for x in sorted(self.servletApiRequires))
            self.assertEqual(req, sreq)

            sprv = '\n'.join('java: ' + x
                for x in sorted(self.servletApiProvides))
            self.assertEqual(prov, sprv)
        self.resetRepository()

    def testFilterOutJavaReqs(self):
        # CNY-3362
        # Make sure we don't make an internal class require another
        # internal class whose deps got pruned

        provides = deps.DependencySet()
        for d in [ 'java.lang.Object' ]:
            provides.addDep(deps.JavaDependencies, deps.Dependency(d, []))
        self.addComponent('fake-jre:runtime', '1', provides = provides)
        self.updatePkg('fake-jre:runtime')
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'test-deps'
    version = '0.1'
    clearBuildReqs()
    buildRequires = [ 'fake-jre:runtime' ]
    def setup(r):
        r.addSource('test-deps.jar', dest='/foo/')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestRequires")
        trv.getName().split(':')[0]+':java'

        troveReq = set(str(x[1]) for x in trv.requires().iterDeps())
        # org.test.A should not be required by the trove
        self.assertFalse('org.test.A' in troveReq)

        troveProv = set(str(x[1]) for x in trv.provides().iterDeps())
        self.assertFalse('org.test.A' in troveProv)
        self.assertIn('org.test.B', troveProv)

    def testExceptJavaProvides(self):
        """
        Test Java provide exceptions
        """
        provides = deps.DependencySet()
        for d in self.servletApiRequires:
            provides.addDep(deps.JavaDependencies, deps.Dependency(d, []))
        self.addComponent('fake-jre:runtime', '1', provides = provides)
        self.updatePkg('fake-jre:runtime')
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.addSource('servlet-api.jar', dest='/foo/')
        r.Provides(exceptDeps='java: .*http.*')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestRequires")
        troveName = trv.getName().split(':')[0]+':java'
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            troveName, trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if 'servlet' not in path:
                continue
            prov = str(fileObj.provides())

            # we explicitly removed java provides with "http"
            sprv = [ x for x in sorted(self.servletApiProvides)
                if '.http.' not in x ]
            sprv = '\n'.join('java: ' + x for x in sprv)
            self.assertEqual(prov, sprv)

    def testExceptJavaRequires(self):
        """
        Test Java provide exceptions
        """
        # CNY-3001 - make sure we honor exceptDeps
        provides = deps.DependencySet()
        # Do not provide the last requires
        for d in self.servletApiRequires[:-1]:
            provides.addDep(deps.JavaDependencies, deps.Dependency(d, []))
        self.addComponent('fake-jre:runtime', '1', provides = provides)
        self.updatePkg('fake-jre:runtime')
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.addSource('servlet-api.jar', dest='/foo/')
        r.Requires(exceptDeps='java: java\..*')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestRequires")
        troveName = trv.getName().split(':')[0]+':java'
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            troveName, trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if 'servlet' not in path:
                continue
            prov = str(fileObj.provides())

            sprv = sorted(self.servletApiProvides)
            sprv = '\n'.join('java: ' + x for x in sprv)
            self.assertEqual(prov, sprv)

    def testExceptAllJavaProvides(self):
        # CNY-2594
        provides = deps.DependencySet()
        for d in self.servletApiRequires:
            provides.addDep(deps.JavaDependencies, deps.Dependency(d, []))
        self.addComponent('fake-jre:runtime', '1', provides = provides)
        self.updatePkg('fake-jre:runtime')
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.addSource('servlet-api.jar', dest='/foo/')
        r.Provides(exceptions=r'.*\.jar$')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestRequires")
        troveName = trv.getName().split(':')[0]+':java'
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            troveName, trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if 'servlet' not in path:
                continue
            prov = str(fileObj.provides())

            self.assertEqual(prov, '')

    def testJavaNullReqsOnFile(self):
        # CNY-3379
        # Mock the java magic to contain None as reqs
        provides = deps.DependencySet()
        for d in [ 'java.lang.Object' ]:
            provides.addDep(deps.JavaDependencies, deps.Dependency(d, []))
        self.addComponent('fake-jre:runtime', '1', provides = provides)
        self.updatePkg('fake-jre:runtime')
        recipestr = """
class TestRequires(PackageRecipe):
    name = 'test-deps'
    version = '0.1'
    clearBuildReqs()
    buildRequires = [ 'fake-jre:runtime' ]
    def setup(r):
        r.addSource('test-deps.jar', dest='/foo/')
"""

        depsContents = {
            'files': {
                'org/test/B.class': (None, None),
                'org/test/A.class': ('org.test.A', set(['java.lang.Object', 'org.test.A'])),
                },
            'requires': set(['org.test.A', 'java.lang.Object']),
            'provides': set(['org.test.A']),
        }

        from conary.lib import magic
        jarMagicClass = mock.mockClass(magic.jar,
            mock_set = mock.MockParams(contents = depsContents))
        self.mock(magic, 'jar', jarMagicClass)

        trv = self.build(recipestr, "TestRequires")
        trv.getName().split(':')[0]+':java'

        troveReq = set(str(x[1]) for x in trv.requires().iterDeps())
        # org.test.A should not be required by the trove
        self.assertFalse('org.test.A' in troveReq)

        troveProv = set(str(x[1]) for x in trv.provides().iterDeps())
        self.assertEqual(troveProv, set([ 'org.test.A', 'test-deps:java' ]))
        troveReqs = set(str(x[1]) for x in trv.requires().iterDeps())
        self.assertEqual(troveReqs, set(['java.lang.Object']))

    def testRequiresRuby(self):
        """
        Test Ruby requirements
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/boot', contents='\n'.join((
            '#!/usr/bin/ruby',
            '',
            "require 'foo/bar'",
            "require 'spam'",
            "require 'eggs'",
            '',
        )), mode=0755)
        r.Create('/usr/lib64/ruby/site_ruby/1.8/foo/bar.rb',
                 contents="require 'blah/baz'")
        r.Create('/usr/lib/ruby/site_ruby/blah/baz.rb')
        r.Create('/usr/lib64/ruby/gems/1.8/gems/spam-1.0.0/lib/spam.rb')
        r.Create('/usr/lib/ruby/gems/1.8/gems/eggs-1.0.0/lib/eggs.rb')

        #FLAGS
        r.Create('/usr/bin/ruby', contents='\n'.join((
            '#!/bin/sh',
            'case $@ in',
            '*RUBY_VERSION*)',
            '  echo 1.8.6',
            '  exit 0',
            '  ;;',
            '*require*bar*)',
            '  echo blah/baz.rb',
            '  exit 0',
            '  ;;',
            '*require*blah*)',
            '  exit 0',
            '  ;;',
            '*puts*)',
            r'  echo "/usr/lib/ruby/site_ruby/1.8 /usr/lib/ruby/site_ruby /usr/lib64/ruby/site_ruby/1.8 /usr/lib64/ruby/site_ruby/1.8/x86_64-linux /usr/lib64/ruby/site_ruby /usr/lib64/ruby/1.8 /usr/lib64/ruby/1.8/x86_64-linux /usr/lib64/ruby/gems/1.8/gems /usr/lib/ruby/gems/1.8/gems ." | tr " " "\\n"',
            '  exit 0',
            '  ;;',
            'esac',
            'exit 0',
            )), mode=0755)
        del r.NonMultilibDirectories
"""
        trv = self.build(recipestr, "TestRequires", macros={'lib':'lib64'})
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:runtime', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            prov = str(fileObj.provides())
            if path == '/usr/bin/boot':
                assert('file: /usr/bin/ruby' in req)
                assert('ruby: foo/bar(1.8 lib64)' in req)
                assert('ruby: spam(1.8 lib64)' in req)
                assert('ruby: eggs(1.8 lib)' in req)
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:ruby', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            prov = str(fileObj.provides())
            if path == '/usr/lib64/ruby/site_ruby/1.8/foo/bar.rb':
                assert('ruby: foo/bar(1.8 lib64)' in prov)
                assert('ruby: blah/baz(lib)' in req)
            elif path == '/usr/lib/ruby/site_ruby/blah/baz.rb':
                assert('ruby: blah/baz(lib)' in prov)
                assert(not req)
            elif path == '/usr/lib64/ruby/gems/1.8/gems/spam-1.0.0/lib/spam.rb':
                assert('ruby: spam(1.8 lib64)' in prov)
                assert(not req)
            elif path == '/usr/lib/ruby/gems/1.8/gems/eggs-1.0.0/lib/eggs.rb':
                assert('ruby: eggs(1.8 lib)' in prov)
                assert(not req)
        self.resetRepository()

        # All the #FLAGS modifications test CNY-3443
        trv = self.build(recipestr.replace('#FLAGS',
            "r.Requires(removeFlagsByDependencyClass=('ruby', ('lib', 'lib64')))"),
            "TestRequires", macros={'lib':'lib64'})
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:runtime', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            if path == '/usr/bin/boot':
                assert('ruby: foo/bar(1.8)' in req)
                assert('ruby: spam(1.8)' in req)
                assert('ruby: eggs(1.8)' in req)
        self.resetRepository()
        trv = self.build(recipestr.replace('#FLAGS',
            "r.Requires(removeFlagsByDependencyClass=('ruby', 'lib.*'))"),
            "TestRequires", macros={'lib':'lib64'})
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:runtime', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            if path == '/usr/bin/boot':
                assert('ruby: foo/bar(1.8)' in req)
                assert('ruby: spam(1.8)' in req)
                assert('ruby: eggs(1.8)' in req)
        self.resetRepository()
        trv = self.build(recipestr.replace('#FLAGS',
            "r.Requires(removeFlagsByDependencyClass=('ruby', ('lib', 'lib64')));r.Requires(removeFlagsByDependencyClass=('ruby', ('1.8', '1.9')))"),
            "TestRequires", macros={'lib':'lib64'})
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:runtime', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            prov = str(fileObj.provides())
            if path == '/usr/bin/boot':
                assert('file: /usr/bin/ruby' in req)
                assert('ruby: foo/bar' in req)
                assert('ruby: spam' in req)
                assert('ruby: eggs' in req)

    def testModuleFinderProxy(self):
        # CNY-2087

        # Make sure that a broken module doesn't cause breakage after it
        root = os.path.join(self.workDir, '_ROOT_')
        pythonPath, _ = os.__file__.rsplit(os.sep, 1)

        def error(*args, **kwargs):
            pass

        file1 = os.path.join(root, pythonPath[1:], 'broken.py')
        file2 = os.path.join(root, pythonPath[1:], 'notbroken.py')

        util.mkdirChain(os.path.dirname(file1))

        self.writeFile(file1, """\
from __future__ import nested_scopes, braces

def f(x):
    def g(y):
        return x + y
    return g

print f(2)(4)
""")

        self.writeFile(file2, """\
#!/usr/bin/python

import os
from bogus import missing
""")

        finderModule = pydeps.moduleFinderProxy('/usr/bin/python', root,
            '/usr/lib', [ pythonPath ], error)

        try:
            finderModule.load_file(file2)
            deps = finderModule.getDepsForPath(file2)
            self.assertEqual(deps, {
                'result': 'ok',
                'paths': set([ os.path.join(pythonPath, 'os.py') ]),
                'missing': set(['bogus']),
                })

            finderModule.load_file(file1)
            deps = finderModule.getDepsForPath(file1)
            self.assertEqual(deps, {'result': 'invalid'})

            finderModule.load_file(file2)
            deps = finderModule.getDepsForPath(file2)
            self.assertEqual(deps, {
                'result': 'ok',
                'paths': set([ os.path.join(pythonPath, 'os.py') ]),
                'missing': set(['bogus']),
                })
        finally:
            finderModule.close()

    @conary_test.installed_conarydb
    def testRequiresPython(self):
        """
        Test Python requirements
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/boot', contents='\n'.join((
            '#!/usr/bin/python',
            '',
            # os.path is weird
            #'from os import path',
            'from logging import handlers',
            'import xml.sax',
            '',
        )), mode=0755)
        r.Create('/usr/bin/python', contents='\n'.join((
            '#!/bin/sh',
            #'exec 2>>/tmp/asdf',
            #'set -x',
            '[ "$LD_LIBRARY_PATH" = "${LD_LIBRARY_PATH/_ROOT_}" ] && exit 1',
            'unset LD_LIBRARY_PATH',
            'case "$@" in *sys.path*)',
            r'  echo "%(destdir)s%(libdir)s/python%(pyver)s/site-packages %(destdir)s%(libdir)s/python%(pyver)s %(libdir)s/python%(pyver)s/site-packages %(libdir)s/python%(pyver)s" | tr " " "\\0"',
            '  exit 0',
            '  ;;',
            'esac',
            'exec python "$@"',
            )), mode=0755)
        r.Requires(bootstrapPythonFlags=['%(pyver)s', 'lib'])
        r.Create('%(libdir)s/python%(pyver)s/os/path.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/xml/sax.py')
"""
        trv = self.build(recipestr, "TestRequires",
            macros = dict(pyver = pythonVer))
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if path == '/usr/bin/boot':
                req = str(fileObj.requires())
                self.assertIn('python: logging(%s lib)' % pythonVer, req)
                self.assertIn('python: logging.handlers(%s lib)' % pythonVer, req)
                self.assertIn('python: xml.sax(%s lib)' % pythonVer, req)
                self.assertIn('python: xml(%s lib)' % pythonVer, req)
        self.resetRepository()


        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/foo', contents='\n'.join((
            '#!/usr/bin/python',
            '',
            'import logging',
            'import xml.sax',
            '',
        )), mode=0755)
"""

        def mockedITBP(real, pythonFlags, localDB, *args ,**kwargs):
            targetPath = args[1]
            if targetPath in set(('/usr/bin/python',
                                  '/usr/lib/python%s/logging/__init__.py' % pythonVer,
                                  '/usr/lib64/python%s/logging/__init__.py' % pythonVer)
                                ) or 'xml/sax' in targetPath:
                newArgs = (localDB, targetPath)
                troveList = real(*newArgs, **kwargs)
                pythonTrv = troveList[0]
                pythonReqs = deps.DependencySet()
                for depClass, dep in pythonTrv.getRequires().iterDeps():
                    flags = dep.getFlags()[0]
                    if depClass == deps.PythonDependencies:
                        if pythonFlags:
                            flags = [ (x, deps.FLAG_SENSE_REQUIRED)
                                      for x in [pythonVer, 'lib'] ]
                        else:
                            flags = []
                        pythonReqs.addDep(depClass, deps.Dependency(dep.getName()[0], flags))
                    else:
                        pythonReqs.addDep(depClass, deps.Dependency(dep.getName()[0], flags))
                pythonTrv.setRequires(pythonReqs)
                return [pythonTrv]
            return real(*args, **kwargs)

        def mockedGFS(real, pythonFlags, localDB, *args ,**kwargs):
            # look first in the test db, then on system db if that fails
            ret = None
            try:
                ret = real(*args, **kwargs)
            except:
                pass
            if not ret:
                newArgs = (localDB, args[1])
                ret = real(*newArgs, **kwargs)
            return ret

        def mockedRFI(self, pythonFlags, *args ,**kwargs):
            files.File.__init__(self, *args, **kwargs)
            reqs = deps.DependencySet()
            for depClass, dep in self.requires().iterDeps():
                flags = dep.getFlags()[0]
                if depClass == deps.PythonDependencies:
                    if pythonFlags:
                        flags = [ (x, deps.FLAG_SENSE_REQUIRED)
                                  for x in [pythonVer, 'lib'] ]
                    else:
                        flags = []
                    reqs.addDep(depClass, deps.Dependency(dep.getName()[0], flags))
                else:
                    reqs.addDep(depClass, deps.Dependency(dep.getName()[0], flags))
            self.requires.set(reqs)

        iTBP = database.Database.iterTrovesByPath
        gFS = database.Database.getFileStream
        localDB = database.Database('/', '/var/lib/conarydb')
        pythonFlags = True
        self.mock(database.Database, 'iterTrovesByPath',
            lambda *args, **kwargs: mockedITBP(iTBP, pythonFlags, localDB,
                                               *args, **kwargs))
        self.mock(database.Database, 'getFileStream',
            lambda *args, **kwargs: mockedGFS(gFS, pythonFlags, localDB,
                                              *args, **kwargs))
        self.mock(files.RegularFile, '__init__',
            lambda self, *args, **kwargs: mockedRFI(self, pythonFlags,
                                              *args, **kwargs))

        # Add flags even if they don't exist and test the new way
        trv = self.build(recipestr, "TestRequires",
            macros = dict(pyver = pythonVer))
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            self.assertIn('python: logging(%s lib)' % pythonVer, req)
            self.assertIn('python: xml.sax(%s lib)' % pythonVer, req)
            # parent must be required
            self.assertIn('python: xml(%s lib)' % pythonVer, req)
        self.resetRepository()

        # Now kill the flags even if they exist and test the old way
        pythonFlags = False
        trv = self.build(recipestr, "TestRequires",
            macros = dict(pyver = pythonVer))
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires()) + '\n'
            assert('python: logging\n' in req)
            assert('python: xml.sax\n' in req)
            # parent must be required
            assert('python: xml\n' in req)
        self.resetRepository()


        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/foo', contents='\n'.join((
            '#!/usr/bin/python',
            '',
            'from logging import handlers',
            'import xml.sax',
            '',
        )), mode=0755)
        r.Create('/usr/bin/python', contents='\n'.join((
            '#!/bin/sh',
            'case "$@" in *sys.path*)',
            r'  echo "%(destdir)s/%(libdir)s/python%(pyver)s/site-packages %(destdir)s%(libdir)s/python%(pyver)s %(libdir)s/python%(pyver)s/site-packages %(libdir)s/python%(pyver)s" | tr " " "\\0"',
            '  exit 0',
            '  ;;',
            'esac',
            'exec python "$@"',
            )), mode=0755)
        r.Create('%(libdir)s/python%(pyver)s/logging/__init__.py')
        r.Create('%(libdir)s/python%(pyver)s/logging/handlers.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/xml/__init__.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/xml/sax.py')
"""
        trv = self.build(recipestr, "TestRequires",
            macros = dict(pyver = pythonVer))
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if path == '/usr/bin/foo':
                req = str(fileObj.requires())
                assert('python: logging.handlers\n' in req)
                assert('python: xml.sax' in req)
                # parent must be required
                assert('python: logging\n' in req)
                assert('python: xml\n' in req)
        self.resetRepository()


    def testPythonFlagNamespace(self):
        """
        Test Python flag requirements
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/boot', contents='\n'.join((
            '#!/usr/conary/bin/python%(pyver)s',
            '',
            'from logging import handlers',
            'import xml.sax',
            '',
        )), mode=0755)
        r.Create('/usr/conary/bin/python%(pyver)s', contents='\n'.join((
            '#!/bin/sh',
            #'exec 2>>/tmp/asdf',
            #'set -x',
            #'[ "$LD_LIBRARY_PATH" = "${LD_LIBRARY_PATH/_ROOT_}" ] && exit 1',
            'case "$@" in *sys.path*)',
            r'  echo "%(destdir)s%(prefix)s/conary/%(lib)s/python%(pyver)s/site-packages %(destdir)s%(prefix)s/conary/%(lib)s/python%(pyver)s %(prefix)s/conary/%(lib)s/python%(pyver)s/site-packages %(prefix)s/conary/%(lib)s/python%(pyver)s" | tr " " "\\0"',
            '  exit 0',
            '  ;;',
            'esac',
            #'unset LD_LIBRARY_PATH',
            'exec /usr/bin/python "$@"',
            )), mode=0755)
        r.Requires(bootstrapSysPath=[
            '%(prefix)s/conary/lib/python%(pyver)s',
            '%(prefix)s/conary/lib/python%(pyver)s/site-packages'])
        r.Requires(bootstrapPythonFlags=['%(pyver)s', '%(lib)s'],
                   pythonFlagNamespace='conary')
        r.Create('%(prefix)s/conary/%(lib)s/python%(pyver)s/logging/__init__.py',
                contents='#!/usr/conary/bin/python%(pyver)s')
        r.Create('%(prefix)s/conary/%(lib)s/python%(pyver)s/site-packages/xml/__init__.py',
                contents='#!/usr/conary/bin/python%(pyver)s')
        r.Create('%(prefix)s/conary/%(lib)s/python%(pyver)s/logging/handlers.py',
                 contents='#!/usr/conary/bin/python%(pyver)s')
        r.Create('%(prefix)s/conary/%(lib)s/python%(pyver)s/site-packages/xml/sax.py',
                 contents='#!/usr/conary/bin/python%(pyver)s')
        r.ComponentSpec('runtime', '%(prefix)s/conary/')
        r.Provides('file', '/usr/conary/bin/python%(pyver)s')
"""
        log.setVerbosity(log.DEBUG)
        self.logFilter.add()
        trv = self.build(recipestr, "TestRequires",
            macros = dict(pyver = pythonVer))
        self.logFilter.remove()
        repos = self.openRepository()
        depMap = {} # basename: (prov, req)
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            depMap[os.path.basename(path)] = (
                str(fileObj.provides()),
                str(fileObj.requires()))

        self.assertIn(
            'python: xml.sax(conary:%s conary:lib' % pythonVer,
            depMap['sax.py'][0])

        self.assertIn(
            'python: logging.handlers(conary:%s conary:lib' % pythonVer,
            depMap['handlers.py'][0])


        self.assertIn(
            'python: logging(conary:%s conary:lib' % pythonVer,
            depMap['boot'][1])
        self.assertIn(
            'python: logging.handlers(conary:%s conary:lib' % pythonVer,
            depMap['boot'][1])
        self.assertIn(
            'python: xml.sax(conary:%s conary:lib' % pythonVer,
            depMap['boot'][1])
        self.assertIn(
            'python: xml(conary:%s conary:lib' % pythonVer,
            depMap['boot'][1])


    @conary_test.installed_conarydb
    def testRequiresPythonWithPth(self):
        """
        Test Python requirements when they are provided using a new .pth
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(libdir)s/python%(pyver)s/site-packages/fdsjklf/blah.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/fdsjklf/__init__.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/gtk.pth',
                 contents='fdsjklf')

        r.Create('%(bindir)s/foo', contents='\n'.join((
            '#!/usr/bin/python',
            '# this is evil.  We import from fdsjklf directly just to ',
            '# mess things up.',
            'import fdsjklf.blah',
            'import blah'
        )), mode=0755)
"""
        trv = self.build(recipestr, "TestRequires",
            macros = dict(pyver = pythonVer))
        req = str(trv.getRequires())
        assert('python: blah' in req)
        assert('python: fdsjklf' in req)
        assert('python: __init__' not in req)

    def testRequiresPythonWithExternalPth(self):
        """
        Test Python requirements when they are provided using a new .pth
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(libdir)s/python%(pyver)s/site-packages/gtk-2.0/blah.py')
"""
        pyGtkPth = glob.glob('/usr/*/python%s/site-packages/pygtk.pth' % pythonVer)
        if not pyGtkPth:
            raise testhelp.SkipTestException('pygtk.pth must be on system for this test')
        if file(pyGtkPth[0]).read().strip() != 'gtk-2.0':
            raise testhelp.SkipTestException('pygtk.pth must contain "gtk-2.0" for this test (update test, please!)')
        trv = self.build(recipestr, "TestRequires",
            macros = dict(pyver = pythonVer))
        prov = str(trv.getProvides())
        assert('python: blah' in prov)

    @conary_test.installed_conarydb
    def testPythonSOdeps(self):
        # CNY-1077
        # Load elf and copy it in the local directory
        from conary.lib import elf

        sourceDir = os.path.join(self.workDir, 'sourceSearch')
        self.cfg.sourceSearchDir = sourceDir
        util.mkdirChain(sourceDir)

        # Python < 2.5 uses "foomodule.so", but Red Hat seems to keep this
        # behavior even with newer versions. So just import the module to
        # figure it out.
        itertoolsModuleName = os.path.basename(
                itertools.__file__).split('.')[0]

        libPath = os.path.dirname(elf.__file__)
        util.copyfile(util.joinPaths(libPath, 'elf.so'),
                      util.joinPaths(sourceDir, 'elf.so'))
        util.copyfile(resources.get_archive('syslog.cpython-34m.so'),
                      util.joinPaths(sourceDir, 'syslog.cpython-34m.so'))
        util.copyfile(util.joinPaths(libPath, 'ext/streams.so'),
                      util.joinPaths(sourceDir, 'streams.so'))
        file(util.joinPaths(sourceDir, "foo.py"), "w+").write("""\
#!/usr/bin/python

import sys
from blah import elf
from blah import syslog
import itertools
""")

        recipestr = r"""
class Blah(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(libdir)s/python%(pyver)s/site-packages/blah/__init__.py')
        r.addSource('elf.so', dest='%(libdir)s/python%(pyver)s/site-packages/blah/')
        r.addSource('syslog.cpython-34m.so', dest='%(libdir)s/python%(pyver)s/site-packages/blah/')
        r.addSource('streams.so', dest='%(libdir)s/python%(pyver)s/site-packages/')
        r.addSource('foo.py', dest='%(libdir)s/python%(pyver)s/site-packages/blah/')
"""
        repos = self.openRepository()
        built, ret = self.buildRecipe(recipestr, "Blah",
            macros = dict(pyver = pythonVer))
        built = [ (b[0], versions.VersionFromString(b[1]), b[2])
                  for b in built if not b[0].endswith(":debuginfo") ]

        trv = repos.getTroves(built)[0]

        if use.Arch.x86_64:
            lib = 'lib64'
        else:
            lib = 'lib'
        dep = "python: blah.elf(%s %s)" % (pythonVer, lib)
        provides = str(trv.getProvides())
        self.assertTrue(dep in provides, "%s not in %s" %
                (dep, provides))
        dep = "python: blah.elf(%s %s)" % (pythonVer, lib)
        self.assertTrue(dep in provides, "%s not in %s" %
                (dep, provides))
        dep = "python: streams(%s %s)" % (pythonVer, lib)
        provides = str(trv.getProvides())
        self.assertTrue(dep in provides, "%s not in %s" %
                (dep, provides))
        dep = "python: streams(%s %s)" % (pythonVer, lib)
        self.assertTrue(dep in provides, "%s not in %s" %
                (dep, provides))
        dep = "python: blah.syslog(%s %s)" % (pythonVer, lib)
        self.assertTrue(dep in provides, "%s not in %s" %
                (dep, provides))

        requires = str(trv.getRequires())
        dep = "python: %s" % itertoolsModuleName
        self.assertTrue(dep in requires, "%s not in %s" %
                (dep, requires))

        # Install the trove, so it gets picked up by the next build
        self.updatePkg("test", depCheck = False)

        recipestr = """
class Bloop(PackageRecipe):
    name = 'bloop'
    version = '1'
    clearBuildReqs()
    buildRequires = [ 'test' ]
    def setup(r):
        r.Create('%(libdir)s/python%(pyver)s/site-packages/bloop/__init__.py')
        r.addSource('foo.py', dest='%(libdir)s/python%(pyver)s/site-packages/bloop/bar.py')
"""

        # Mock the method that sets the python path for the module loader in
        # the build. We need to point it to our root as well as the system
        # root
        from conary.build import packagepolicy
        oldGetPythonSysPath = packagepolicy.Requires._getPythonSysPath
        rootDir = self.rootDir
        def mockedGetPythonSysPath(self, pythonPath, destdir, libdir,
                useDestDir=False):
            ret = oldGetPythonSysPath(self, pythonPath, destdir, libdir,
                    useDestDir=useDestDir)
            return [ util.joinPaths(rootDir, 'usr', lib,
                       'python%s/site-packages' % pythonVer) ] + ret
        self.mock(packagepolicy.Requires, '_getPythonSysPath',
                   mockedGetPythonSysPath)

        # Mock the finder so that we can force a soname that we would not
        # otherwise find
        oldGetPythonRequiresSysPath = packagepolicy.Requires._getPythonRequiresSysPath
        def mockedGetPythonRequiresSysPath(slf, path):
            sysPath, finder, version = oldGetPythonRequiresSysPath(slf, path)
            oldGetDepsForPath = finder.getDepsForPath
            def mockedGetDepsForPath(fullpath):
                ret = oldGetDepsForPath(fullpath)
                if fullpath.endswith("bar.py"):
                    ret["missing"] = set()
                    ret["paths"].add(util.joinPaths(rootDir, 'usr', lib,
                        'python%s/site-packages' % pythonVer, 'blah',
                        'syslog.cpython-34m.so'))
                return ret
            self.mock(finder, 'getDepsForPath', mockedGetDepsForPath)
            return sysPath, finder, version
        self.mock(packagepolicy.Requires, '_getPythonRequiresSysPath',
                  mockedGetPythonRequiresSysPath)

        built, ret = self.buildRecipe(recipestr, "Bloop",
            macros = dict(pyver = pythonVer))
        built = [ (b[0], versions.VersionFromString(b[1]), b[2])
                  for b in built if not b[0].endswith(":debuginfo") ]

        trv2 = repos.getTroves(built)[0]

        # Make sure we got the shorter requirement
        requires = str(trv2.getRequires())
        dep = "python: blah.elf\n"
        self.assertTrue(dep in requires, "%s not in %s" %
                (dep, requires))
        dep = "python: blah.syslog\n"
        self.assertTrue(dep in requires, "%s not in %s" %
                (dep, requires))

        # Test that we pick the right dep when only the old dep is available

        class MockedDbDepCache(packagepolicy._DatabaseDepCache):
            def getProvides(self, depSetList):
                dep = deps.parseDep('python: blah.elf')
                dList = [ x for x in depSetList if x != dep ]
                ret = packagepolicy._DatabaseDepCache.getProvides(self, dList)
                # Filter out short dep
                return ret

        self.mock(packagepolicy.Requires, 'dbDepCacheClass', MockedDbDepCache)

        built, ret = self.buildRecipe(recipestr, "Bloop",
            macros = dict(pyver = pythonVer))
        built = [ (b[0], versions.VersionFromString(b[1]), b[2])
                  for b in built if not b[0].endswith(":debuginfo") ]

        trv3 = repos.getTroves(built)[0]

        requires = str(trv3.getRequires())
        dep = "python: blah.elf"
        self.assertTrue(dep in requires, "%s not in %s" %
                (dep, requires))

        # More mocking, make sure we provide some system flags
        def _getPythonLib(path):
            import subprocess
            p = subprocess.Popen([path, "-c",
                "from distutils import sysconfig; "
                "print sysconfig.get_python_lib(plat_specific=1, standard_lib=1)"],
                stdout = subprocess.PIPE)
            pyLibDir, _ = p.communicate()
            return pyLibDir.strip()

        self.unmock()
        self.mock(packagepolicy.Requires, '_getPythonSysPath',
                   mockedGetPythonSysPath)

        pyLibDir = _getPythonLib('/usr/bin/python')

        # Mock up system python flags
        origGetPythonTroveFlags = packagepolicy.Requires._getPythonTroveFlags
        def mockedGetPythonTroveFlags(foo, pathName):
            x = foo._getPythonFlagsFromPath(pyLibDir)
            foo.pythonTroveFlagCache['/usr/bin/python%s' % pythonVer] = x
            foo.pythonTroveFlagCache['/usr/bin/python'] = x
            foo.pythonFlagCache[pyLibDir + '/lib-dynload/%s.so' % itertoolsModuleName] = x
            return origGetPythonTroveFlags(foo, pathName)
        self.mock(packagepolicy.Requires, '_getPythonTroveFlags',
                  mockedGetPythonTroveFlags)

        built, ret = self.buildRecipe(recipestr, "Bloop",
            macros = dict(pyver = pythonVer))
        built = [ (b[0], versions.VersionFromString(b[1]), b[2])
                  for b in built if not b[0].endswith(":debuginfo") ]

        trv4 = repos.getTroves(built)[0]

        requires = str(trv4.getRequires())
        dep = "python: %s(%s %s)" % (itertoolsModuleName, pythonVer, lib)
        self.assertTrue(dep in requires, "%s not in %s" %
                (dep, requires))

    @conary_test.installed_conarydb
    def testPythonNoarchDeps(self):
        # CNY-2110

        sourceDir = os.path.join(self.workDir, 'sourceSearch')
        self.cfg.sourceSearchDir = sourceDir
        util.mkdirChain(sourceDir)

        if use.Arch.x86_64:
            lib = 'lib64'
        else:
            lib = 'lib'

        file(util.joinPaths(sourceDir, "foo.py"), "w+").write("""\
#!/usr/bin/python

import logging
""")

        recipestr = r"""
class Blah(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(libdir)s/python%(pyver)s/site-packages/blah/__init__.py')
        r.addSource('foo.py', dest='%(libdir)s/python%(pyver)s/site-packages/blah/')
"""
        # Mock the method that sets the python path for the module loader in
        # the build. We need to point it to our root as well as the system
        # root
        from conary.build import packagepolicy

        # More mocking, make sure we provide some system flags
        def _getPythonLib(path):
            import subprocess
            p = subprocess.Popen([path, "-c",
                "from distutils import sysconfig; "
                "print sysconfig.get_python_lib(plat_specific=1, standard_lib=1)"],
                stdout = subprocess.PIPE)
            pyLibDir, _ = p.communicate()
            return pyLibDir.strip()

        pyLibDir = _getPythonLib('/usr/bin/python')

        # Mock up system python flags
        origGetPythonTroveFlags = packagepolicy.Requires._getPythonTroveFlags
        def mockedGetPythonTroveFlags(foo, pathName):
            x = foo._getPythonFlagsFromPath(pyLibDir)
            foo.pythonTroveFlagCache['/usr/bin/python%s' % pythonVer] = x
            foo.pythonTroveFlagCache['/usr/bin/python'] = x
            foo.pythonFlagCache[pyLibDir + '/logging/__init__.py'] = x
            foo.pythonFlagCache[pyLibDir + '/logging/__init__.pyc'] = x
            foo.pythonFlagCache[pyLibDir + '/logging/handlers.py'] = x
            foo.pythonFlagCache[pyLibDir + '/logging/handlers.pyc'] = x
            return origGetPythonTroveFlags(foo, pathName)
        self.mock(packagepolicy.Requires, '_getPythonTroveFlags',
                  mockedGetPythonTroveFlags)

        repos = self.openRepository()
        built, ret = self.buildRecipe(recipestr, "Blah",
            macros = dict(pyver = pythonVer))
        built = [ (b[0], versions.VersionFromString(b[1]), b[2])
                  for b in built if not b[0].endswith(":debuginfo") ]

        trv = repos.getTroves(built)[0]

        if lib == 'lib':
            targetFlv = deps.parseFlavor("is: x86")
        else:
            targetFlv = deps.parseFlavor("is: x86_64")

        # This trove has to be arch flavored
        self.assertEqual(trv.getFlavor(), targetFlv)

        dep = "python: blah.foo(%s %s)" % (pythonVer, lib)
        provides = str(trv.getProvides())
        self.assertIn(dep, provides)

        requires = str(trv.getRequires())
        dep = "python: logging(%s %s)" % (pythonVer, lib)
        self.assertTrue(dep in requires, "%s not in %s" %
                (dep, requires))

    def testRequiresPerlNoBootstrapPerl(self):
        """
        Test Perl requirements when perl is not packaged
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # all perl modules must be provided by package or present on system
        # (CNY-2180)
        r.Create('VENDOR_PERL/CGI/Util.pl', contents='\n'.join((
            '#!/usr/bin/perl',
            '',
            'package CGI::Util;',
            '',
        )), mode=0755)
        r.Create('%(bindir)s/foo', contents='\n'.join((
            '#!/usr/bin/perl',
            '',
            'use CGI::Util;',
            '',
        )), mode=0755)
""".replace('VENDOR_PERL', _findVendorPerl())
        self.resetRepository()
        self.logFilter.add()
        trv = self.build(recipestr, "TestRequires")
        self.logFilter.remove()
        # ensure that we find the missing build requirement
        assert('warning: Requires: interpreter file /usr/bin/perl not managed by conary' in self.logFilter.records)
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            req = str(fileObj.requires())
            assert('perl: CGI::Util' in req)
        self.resetRepository()

    def testRequiresPerlWithoutPerl(self):
        """
        Test Perl requirements when perl is not available at all
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('VENDOR_PERL/CGI/Util.pl', contents='\n'.join((
            '#!/usr/bin/perl',
            '',
            'package CGI::Util;',
            '',
        )), mode=0755)
""".replace('VENDOR_PERL', _findVendorPerl())
        realAccess = os.access
        def access_perl(*args):
            if args[0] == '/usr/bin/perl':
                return False
            return realAccess(*args)
        self.mock(os, 'access', access_perl)
        self.build(recipestr, "TestRequires")

    def testRequiresMissingPerlModule(self):
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # all perl modules must be provided by package or present on system
        # (CNY-2180)
        r.Create('VENDOR_PERL/CGI/Util.pl', contents='\n'.join((
            '#!/usr/bin/perl',
            '',
            'package CGI::Util;',
            '',
        )), mode=0755)

        r.Create('%(bindir)s/foo', contents='\n'.join((
            '#!/usr/bin/perl',
            '',
            'use CGI::Util;',
            'use DFSJFSD::FDSJFK;',
            '',
        )), mode=0755)
""".replace('VENDOR_PERL', _findVendorPerl())
        repos = self.openRepository()
        trv = self.build(recipestr, "TestRequires")
        data = [(path, str(fileObj.requires()), str(fileObj.provides()))
                for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True)]
        self.assertEqual(len(data), 1)
        data = data[0]
        self.assertEqual(data[0], '/usr/bin/foo')
        self.assertIn('perl: CGI::Util', data[1])
        self.assertNotIn('perl: DFSJFSD::FDSJFK', data[1])
        self.assertEqual(data[2], '')

    def testRequiresPerlWithPerl(self):
        """
        Test Perl requirements when perl is packaged
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/perl', contents='\n'.join((
            '#!/bin/bash',
            '',
            'case $1 in',
            '  *INC*) ;;',
            '   *) echo "module///usr/lib/perl5/5.8.7/CGI/Util.pm//CGI/Util.pm\nmodule////deptest.pm\nmodule////foo/deptest.pm\n/perlbase" ;;',
            #'   *) echo "module///usr/lib/perl5/5.8.7/CGI/Util.pm//CGI/Util.pm" ;;',
            'esac',
            '',
            'exit 0',
            '',
        )), mode=0755)
        r.Create('%(bindir)s/foo.pl', contents='\n'.join((
            '',
            'use CGI::Util;',
            '',
        )), mode=0755)
"""
        db = self.openDatabase()
        self.addDbComponent(db, name = 'cgi-apache',
                version = 'test.rpath.loacl@rpl:test',
                provides = deps.parseDep('perl: CGI::Util'))
        self.resetRepository()
        trv = self.build(recipestr, "TestRequires")
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if 'foo.pl' in path:
                req = str(fileObj.requires())
                assert('perl: CGI::Util' in req)
        self.resetRepository()

    def testProvidesPerlWithIncompatibleCrossPerl(self):
        """
        Test Perl requirements when system perl can't be run
        CNY-2943
        """
        self.addComponent("perl:runtime", "1", fileContents = [
            ('/usr/bin/perl', rephelp.RegularFile(contents='\n'.join((
                '#!/bin/sh',
                'kill -9 $$',
                '',
                )), perms=0o755)),
        ])
        self.updatePkg('perl:runtime')
        recipestr = r"""
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    buildRequires = ['perl:runtime']
    def setup(r):
        # CNY-2949 - symlinks in @INC
        r.Symlink('/opt/perl/5.8.8', '/opt/perl/5.8')
        r.Create('/opt/perl/5.8.8/foo.pm', mode=0755)
        r.Create('/opt/perl/other/bar.pm', mode=0755)
        r.Requires(bootstrapPerlIncPath=['/opt/perl/5.8', '/opt/perl/other'])
"""
        realGetPerlIncPath = packagepolicy._dependency._getperlincpath
        def mockedGetPerlIncPath(k, perl, destdir):
            return realGetPerlIncPath(k, self.workDir+'/usr/bin/perl', destdir)
        self.mock(packagepolicy._dependency, '_getperlincpath',
                  lambda *args, **kwargs:
                  mockedGetPerlIncPath(*args, **kwargs))
        trv = self.build(recipestr, "TestProvides")
        repos = self.openRepository()
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if 'foo.pm' in path:
                prov = str(fileObj.provides())
                assert('perl: 8::foo' not in prov) #CNY-2949
                assert('perl: foo' in prov)
                found += 1
            if 'bar.pm' in path:
                prov = str(fileObj.provides())
                assert('perl: bar' in prov)
                found += 1
        self.assertEqual(found, 2)

    def testProvidesPerlWithIncompatibleLibraryPerl(self):
        """
        Test Perl requirements when perl can't be run without LD_LIBRARY_PATH
        CNY-2955
        """
        recipestr = r"""
class TestProvides(PackageRecipe):
    name = 'perl'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/bin/perl', contents='\n'.join((
                '#!/bin/sh',
                '[ -z "$LD_LIBRARY_PATH" ] && kill -9 $$', # CNY-2959
                '',
                'case $* in',
                '  *INC*)',
                '      echo /opt/perl/5.8',
                '      echo /opt/perl/other',
                '      ',
                '  ;;',
                'esac',
                '',
                'exit 0',
                '',
                )), mode=0755)
        # CNY-2949 - symlinks in @INC
        r.Symlink('/opt/perl/5.8.8', '/opt/perl/5.8')
        r.Create('/opt/perl/5.8.8/foo.pm', mode=0755)
        r.Create('/opt/perl/other/bar.pm', mode=0755)
"""
        trv = self.build(recipestr, "TestProvides")
        repos = self.openRepository()
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if 'foo.pm' in path:
                prov = str(fileObj.provides())
                assert('perl: 8::foo' not in prov) #CNY-2949
                assert('perl: foo' in prov)
                found += 1
            if 'bar.pm' in path:
                prov = str(fileObj.provides())
                assert('perl: bar' in prov)
                found += 1
        self.assertEqual(found, 2)

    def testDroppedPerlRequires(self):
        """
        Test Perl requirements referenced by file.
        """
        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/perl', contents='\n'.join((
            '#!/bin/bash',
            'print $*',
            '',
            'case $1 in',
            '  *INC*) ;;',
            '   *) echo "module///usr/lib/perl5/5.8.7/CGI/Util.pm//CGI/Util.pm\nmodule////deptest.pm\nmodule////foo/deptest.pm\n/perlbase" ;;',
            'esac',
            '',
            'exit 0',
            '',
        )), mode=0755)
        r.Create('%(bindir)s/foo.pl', contents='\n'.join((
            '',
            "require 'deptest.pm'",
            "require foo::deptest",
            'use CGI::Util;',
            '',
        )), mode=0755)
        r.Create('/perlbase/foo/deptest.pm', contents = "#!/usr/bin/perl\n\npackage foo::deptest;", mode = 0755)
"""
        self.resetRepository()
        repos = self.openRepository()

        trv = self.build(recipestr, "TestRequires")
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trv.getName(), trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if 'foo.pl' in path:
                req = str(fileObj.requires())
                assert('perl: foo::deptest' in req)
                self.assertFalse('perl: deptest' in req)
                # CGI::Util was dropped because it wasn't in the conary db
                self.assertFalse('perl: CGI::Util' in req)
        self.resetRepository()

    def testInternalRpathWithMultipleFlags(self):

        recipestr = """
class TestProvidesMap(PackageRecipe):
    name = 'provides'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.macros.jd = '%(libdir)s/jvm/sun-java-1.5.0_07/jre/lib/i386'
        r.addSource('java-libjava.so', dest='%(jd)s/libjava.so')
        r.addSource('java-libverify.so', dest='%(jd)s/libverify.so')
"""
        self.resetRepository()
        trv = self.build(recipestr, "TestProvidesMap")
        repos = self.openRepository()
        found = 0
        if use.Arch.x86_64:
            verifySoname = 'soname: ELF32/usr/lib64/jvm/sun-java-1.5.0_07/jre/lib/i386/libverify.so(SUNWprivate_1.1 SysV x86)'
        else:
            verifySoname = 'soname: ELF32/usr/lib/jvm/sun-java-1.5.0_07/jre/lib/i386/libverify.so(SUNWprivate_1.1 SysV x86)'
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            trv.getName(), trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            if 'libjava' in path:
                req = str(fileObj.requires())
                self.assertIn(verifySoname, req)
                found += 1
            elif 'libverify' in path:
                prov = str(fileObj.provides())
                self.assertIn(verifySoname, prov)
                found += 1
        assert(found == 2)
        self.resetRepository()


    def testRequiresRpath(self):
        """
        Test requiring an rpath
        """

        recipestrProvides = """
class TestProvides(PackageRecipe):
    name = 'provides'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('notfound.c', contents='void notfound(void) { return ; }')
        r.Run('gcc -fPIC -g -c -o notfound.o notfound.c')
        r.Run('gcc -g -shared -Wl,-soname,libnotfound.so.0 -o libnotfound.so.0.0 notfound.o -nostdlib')
        r.Symlink('libnotfound.so.0.0', 'libnotfound.so.0')
        r.Symlink('libnotfound.so.0', 'libnotfound.so')
        r.Install('libnotfound*', '/opt/notfound/%(lib)s/')
        # now make shlib handler happy with fake ldconfig
        r.Run('''
cat > true.c <<'EOF'
int main() {
    return 0;
}
EOF
        ''')
        r.Run('%(cc)s %(ldflags)s -static -o true true.c')
        r.Install('true', '%(essentialsbindir)s/ldconfig', mode=0755)
        r.ComponentSpec('runtime', '.*')
"""

        recipestrRequires = """
class TestRequires(PackageRecipe):
    name = 'requires'
    version = '1'
    clearBuildReqs()
    buildRequires = [ 'provides:runtime' ]
    def setup(r):
        r.Create('findnot.c',
                 contents='void notfound(void); int main(void) { notfound() ; return 0;}')
        r.Make('findnot.o')
        r.Run('gcc -o findnot findnot.o'
              ' -Wl,-rpath,%%(libdir)s:/ignoreme:%(workdir)s/opt/notfound/%%(lib)s'
              ' -L%(workdir)s/opt/notfound/%%(lib)s/ -lnotfound')
        r.Install('findnot', '%%(bindir)s/')
        r.ComponentSpec('runtime', '.*')
        r.CheckDestDir(exceptions='.*')
"""

        recipestrRequiresNoRpath = """
class TestRequires(PackageRecipe):
    name = 'requires'
    version = '2'
    clearBuildReqs()
    buildRequires = [ 'provides:runtime' ]
    def setup(r):
        r.Create('findnot.c',
                 contents='void notfound(void); int main(void) { notfound() ; return 0;}')
        r.Make('findnot.o')
        r.Run('gcc -o findnot findnot.o'
              ' -L%(workdir)s/opt/notfound/%%(lib)s/ -lnotfound')
        r.Install('findnot', '%%(bindir)s/')
        # test synthetic soname requirements -- here because we build a
        # binary here anyway; probably ought to be its own test...
        r.Requires('soname: asdf.so', '%%(bindir)s/')
        r.Requires('soname: fdsa.so(BLAH)', '%%(bindir)s/')
        # Test full path requirements
        r.Requires('soname: /usr/kerberos/lib/libkrb4.so', '%%(bindir)s/')
        # test all code paths
        r.Requires(rpath=('%%(bindir)s/', '%(workdir)s/opt/*found/%%(lib)s'))
        r.Requires(rpath='%(workdir)s/opt/not*/%%(lib)s')
        r.ComponentSpec('runtime', '.*')
        r.CheckDestDir(exceptions='.*')
"""
        self.reset()
        repos = self.openRepository()
        # Note that workdir has to be in the soname because it is looked
        # up in the destdir and the root; the workdir just isn't passed
        # in to conary in any way
        sonamePathRE = re.compile(r'soname: ELF[^/]*/.*/opt/notfound/lib.*/lib.*\.so.*\.0')
        sonameBadSysRE = re.compile(r'soname: ELF[^/]*/usr(64)?/lib[0-9]*\.so.*\.0')
        syntheticSonameRE = re.compile(r'soname: ELF[^/]*/asdf.so\(.*\)')
        syntheticFlagSonameRE = re.compile(r'soname: ELF[^/]*/fdsa.so\(.*BLAH.*\)')
        syntheticFullPathSonameRE = re.compile(r'soname: ELF[^/]*/usr/kerberos/lib/libkrb4.so\(.*\)')
        built, d = self.buildRecipe(recipestrProvides, "TestProvides")
        self.updatePkg(self.workDir, 'provides', '1')
        d = { 'workdir' : self.workDir}
        trv = self.build(recipestrRequires % d, "TestRequires")
        troveList = [repos.getTrove('requires:runtime', trv.getVersion(),
                                     trv.getFlavor())]
        trv = self.build(recipestrRequiresNoRpath % d, "TestRequires")
        troveList.append(repos.getTrove('requires:runtime', trv.getVersion(),
                                        trv.getFlavor()))
        for trv in troveList:
            foundPath = False
            for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'requires:runtime', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
                if path == '/usr/bin/findnot':
                    foundPath = True
                    req = str(trv.getRequires())
                    assert(sonamePathRE.search(req))
                    assert(not sonameBadSysRE.search(req))
                    assert('//' not in req)
                    if '2-1-1' in version.asString():
                        assert(syntheticSonameRE.search(req))
                        assert(syntheticFullPathSonameRE.search(req))
                        assert(syntheticFlagSonameRE.search(req))
            assert(foundPath)
        self.reset()


    def testRequiresPkgConfig(self):
        """
        Test adding trove requirements based on Requires: lines
        in .pc files
        """
        if not glob.glob('/usr/lib*/pkgconfig/libgcj.pc'):
            raise testhelp.SkipTestException('libgcj.pc must be on system for this test')

        # first, we need to prime the database so that something
        # in the config root provides this file
        recipestrprov = r"""
class TestProvGccJava(PackageRecipe):
    name = 'gcc-java'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # put the file in (will be in :devellib)
        r.Create('%(libdir)s/pkgconfig/libgcj.pc')
        # make a :devel to look at
        r.Create('%(includedir)s/gcj.h')
"""
        trv = self.build(recipestrprov, "TestProvGccJava")
        self.updatePkg('gcc-java')

        recipestrprovlib = r"""
class TestProvLib(PackageRecipe):
    name = 'bar'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # put the file in (will be in :devellib)
        r.macros.prefix='/opt/bar'
        r.Create('/opt/bar/lib/libbar.so')
        # make a :devel to look at
        r.Create('%(includedir)s/bar.h')
"""
        trv = self.build(recipestrprovlib, "TestProvLib")
        self.updatePkg('bar')


        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'req'
    version = '1'
    clearBuildReqs()
    buildRequires = ['bar:devel']
    def setup(r):
        r.Create('/linked_datadir/pkgconfig/intdataprov.pc')
        r.Symlink('/linked_datadir', '%(datadir)s')
        r.Create('%(libdir)s/pkgconfig/intlibprov.pc')
        r.PackageSpec('intprov', 'int.*prov.pc')
        # test other components providing .pc files, even
        # though that's rather far-fetched
        r.ComponentSpec('data', '%(datadir)s/pkgconfig/intdataprov.pc')
        # now test internal :devellib -> :devel mapping
        r.Create('%(libdir)s/pkgconfig/develprov.pc')
        r.Create('%(includedir)s/develprov.h')
        r.PackageSpec('develprov', 'develprov.*')
        # finally, a few extras for testing parsing...
        r.Create('%(libdir)s/pkgconfig/a.pc')
        r.PackageSpec('a', 'a.pc')
        r.Create('%(libdir)s/pkgconfig/b.pc')
        r.PackageSpec('b', 'b.pc')
        r.Create('%(libdir)s/pkgconfig/c.pc')
        r.PackageSpec('c', 'c.pc')
        r.Create('/usr/lib/libfoo.a')

        # now the requiring file
        r.Create('%(libdir)s/pkgconfig/req.pc',
                 contents='\n'.join((
                    'indirect=prov',
                    'var1able=${indirect}',
                    'var1able:=broken',
                    'Requires: a,b < 1 c',
                    'Requires: libgcj',
                    'Requires.private: develprov',
                    'Requires: intlibprov intdata${var1able} >= 1',
                    'lib=lib',
                    'libdir=/usr/${lib}',
                    'Lib: -L${libdir} -lfoo -ldoesnotexist -Wl,foo',
                    'Lib.private: -L/opt/bar/lib -lbar',
                    '')))
"""
        self.logFilter.ignore('warning: (EnforceSonameBuildRequirements|FixupMultilibPaths): .*')
        self.logFilter.add()

        def mockedExists(real, root, path):
            if 'libbar' in path and '_ROOT_' not in path:
                return real(root+path)
            return real(path)

        realExists = util.exists
        self.mock(util, 'exists', lambda *args, **kwargs:
                  mockedExists(realExists, self.rootDir, *args, **kwargs))

        reportedBuildReqs = set()
        self.mock(packagepolicy.reportMissingBuildRequires, 'updateArgs',
                  lambda *args:
                    mockedSaveArgSet(args[0], None, reportedBuildReqs, *args[1:]))

        trv = self.build(recipestr, "TestRequires")
        self.logFilter.remove()
        # ensure that we find the missing build requirement
        self.logFilter.compare([
            'warning: Requires: library file libdoesnotexist not found',
        ])
        self.assertEqual(reportedBuildReqs, set(('gcc-java:devel', 'glibc:runtime')))
        repos = self.openRepository()
        req = None
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'req:devellib', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if 'req.pc' in path:
                req = str(fileObj.requires())
                assert('trove: gcc-java:devel' in req)
                assert('trove: gcc-java:devellib' not in req)
                # intprov:data no longer exists, as all .pc files are placed
                # in libdir, therefore we only have intprov:devellib
                #assert('trove: intprov:data' in req)
                assert('trove: intprov:devellib' in req)
                assert('trove: develprov:devel' in req)
                assert('trove: develprov:devellib' not in req)
                assert('trove: a:devel' in req)
                assert('trove: b:devel' in req)
                assert('trove: c:devel' in req)
                assert('trove: bar:devel' in req)
                assert('trove: bar:devellib' not in req)
                assert('trove: req:devel' in req)
        assert(req is not None)

        # Test exceptDeps
        recipestr += "        r.Requires(exceptDeps='trove: develprov:devel')\n"
        self.logFilter.add()
        try:
            os.rename(self.buildDir, self.buildDir + '-real')
            os.symlink(self.buildDir + '-real', self.buildDir)
            trv = self.build(recipestr, "TestRequires")
        finally:
            if os.path.exists(self.buildDir) and os.path.islink(self.buildDir):
                os.unlink(self.buildDir)
            if os.path.exists(self.buildDir + '-real'):
                os.rename(self.buildDir + '-real', self.buildDir)
        #trv = self.build(recipestr, "TestRequires")
        self.logFilter.remove()

        req = None
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'req:devellib', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if 'req.pc' in path:
                req = str(fileObj.requires())
                assert('trove: develprov:devel' not in req)
                break
        assert(req is not None)

        # Test exceptions
        rs = recipestr
        recipestr += '        r.Requires(exceptions="%(libdir)s/pkgconfig/req.pc")\n'
        self.logFilter.add()
        trv = self.build(recipestr, "TestRequires")
        self.logFilter.remove()

        req = None
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'req:devellib', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if 'req.pc' in path:
                req = str(fileObj.requires())
                self.assertEqual(req, '')
                break
        assert(req is not None)

        # Explicit PkgConfigRequires exceptions
        recipestr = rs
        recipestr += '        r.PkgConfigRequires(exceptions="%(libdir)s/pkgconfig/req.pc")\n'

        self.logFilter.add()
        trv = self.build(recipestr, "TestRequires")
        self.logFilter.remove()

        req = None
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'req:devellib', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if 'req.pc' in path:
                req = str(fileObj.requires())
                self.assertEqual(req, '')
                break
        assert(req is not None)


        self.resetRepository()

    def testPkgConfigSymlinks(self):
        """
        Test adding trove requirements based on Requires: lines
        in .pc files. we're testing how the code handles symlinks
        in the required paths.
        """
        recipestrprovlib = r"""
class TestProvLib(PackageRecipe):
    name = 'baz'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # put the file in (will be in :devellib)
        r.macros.prefix='/opt/baz'
        # make a :devel to look at
        r.Create('/symlink/target/include/baz.h')
        r.Symlink('/symlink/target/include', '%(includedir)s')
"""
        trv = self.build(recipestrprovlib, "TestProvLib")
        self.updatePkg('baz')

        recipestr = r"""
class TestRequires(PackageRecipe):
    name = 'req'
    version = '1'
    clearBuildReqs()
    buildRequires = ['baz:devel']
    def setup(r):
        r.Create('/symlink/target/pkgconfig/baz.pc', package = 'test1:lib')
        r.Symlink('/symlink/target/pkgconfig', '%(datadir)s/pkgconfig',
                package = 'test1:lib')
        r.Create('/symlink/target/lib/libbar.so', package = 'test2:lib')
        r.Symlink('/symlink/target/lib', '/opt/bar/lib', package = 'test2:lib')
        r.Create('%(libdir)s/pkgconfig/req.pc',
                 contents='Requires: baz\nLib.private: -L/opt/bar/lib -lbar\n')
"""
        trv = self.build(recipestr, "TestRequires",
                returnTrove='req:devellib')

        #prove that both include and lib requirements were found
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet('4#test1::lib|4#test2::lib'))

    def testRequiresHttpdConfig(self):
        """
        Test adding trove that has a file in /etc/httpd/conf.d/
        depends on httpd:runtime only if it has non-blank, non-comment
        info in it
        """

        recipestr = r"""
class TextHttpdConf(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create("%(sysconfdir)s/httpd/conf.d/test.conf", contents = '\n'.join([
            "  ",
            "# comment",
            "   # indented comment ",
            " CONFIG  ",
        ]))
        r.Create("%(sysconfdir)s/httpd/conf.d/test.foo", contents = '\n'.join([
            "  ",
            "# comment",
            "   # indented comment ",
            " IGNORETHIS  ",
        ]))
"""
        repos = self.openRepository()
        trv = self.build(recipestr.replace("CONFIG", ""), "TextHttpdConf")
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'test:config', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if path == '/etc/httpd/conf.d/test.conf':
                req = str(fileObj.requires())
                self.assertEqual(req, '')
            elif path == '/etc/httpd/conf.d/test.foo':
                req = str(fileObj.requires())
                self.assertEqual(req, '')
            else:
                self.fail('Path %s should not exist' %path)
        trv = self.build(recipestr, "TextHttpdConf")
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'test:config', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if path == '/etc/httpd/conf.d/test.conf':
                req = str(fileObj.requires())
                self.assertEqual(req, 'file: /usr/sbin/httpd')
            elif path == '/etc/httpd/conf.d/test.foo':
                req = str(fileObj.requires())
                self.assertEqual(req, '')
            else:
                self.fail('Path %s should not exist' %path)


    def testRequiresXinetdConfig(self):
        """
        Test adding trove that has a file in /etc/xinetd.d/ with
        "disabled = no"
        """

        recipestr = r"""
class TextXinetd(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create("%(sysconfdir)s/xinetd.d/test", contents = '\n'.join([
            "service test",
            "{",
            "   disable           = EXPANDME",
            "}",
            "",
        ]))
"""
        repos = self.openRepository()
        trv = self.build(recipestr.replace("EXPANDME", "no"), "TextXinetd")

        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'test:config', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            self.assertEqual(path, '/etc/xinetd.d/test')
            req = str(fileObj.requires())
            self.assertEqual(req, 'file: /usr/sbin/xinetd')

        trv = self.build(recipestr.replace("EXPANDME", "yes"), "TextXinetd")
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                'test:config', trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            self.assertEqual(path, '/etc/xinetd.d/test')
            req = str(fileObj.requires())
            self.assertEqual(req, '')

    def testPkgConfigRequiresExceptions(self):
        recipeStr = """
class UnusedPkgConfig(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildRequires()

    def setup(r):
        r.Create('/foo')
        r.PkgConfigRequires(exceptions = '/bar')
        r.Requires(exceptions = '/baz')
"""
        self.logFilter.add()
        self.build(recipeStr, 'UnusedPkgConfig')
        self.logFilter.remove()
        self.assertEqual(self.logFilter.records,
                ['warning: Requires: Exception ^/bar$ for '
                        'PkgConfigRequires was not used',
                 'warning: Requires: Exception ^/baz$ for '
                        'Requires was not used'])


class ProvidesTest(rephelp.RepositoryHelper):
    def testProvides(self):
        """
        Test provides and related requirements
        """

        recipestr1 = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/foo')
        r.Provides('abi: ELF32(SysV x86)', '/foo')
        r.Create('/bar')
        r.Symlink('/bar', '/blah')
        r.Provides('file', '/(bar|blah)')
        r.MakeDirs('%(libdir)s')
        r.Create('foo.c', contents='void foo(void) { return ; }')
        r.Run('make CFLAGS="-g -fPIC" foo.o')
        r.Run('ar r libfoo.a foo.o')
        # note: no -Wl,-soname,libfoo.so.0 below
        r.Run('gcc -g -shared -o libfoo.so.0.0 foo.o -nostdlib')
        r.Run('gcc -g -shared -Wl,-soname,libnoversion.so -o libnoversion.so foo.o -nostdlib')
        r.Install('libfoo*', '%(libdir)s/')
        r.Install('libnoversion.so', '%(libdir)s/')
        r.Symlink('libfoo.so.0.0', '%(libdir)s/libfoo.so')
        r.Provides('soname: libfoo.so.0(asdf)', '%(libdir)s/libfoo.so.0.0')
        r.Install('libfoo.so.0.0', '%(libdir)s/foobar/')
        r.Provides('soname: %(libdir)s/foobar/libfoo.so.0',
                   '%(libdir)s/foobar/libfoo.so.0.0')
        r.Symlink('libfoo.so.0.0', '%(libdir)s/libasdf1.so')
        r.Symlink('libasdf1.so', '%(libdir)s/libfdsa2.so')
        r.Provides('soname: libfdsa2.so', '%(libdir)s/libfdsa2.so')

        # and test silly sonames that include a path in the soname proper
        r.Run('gcc -g -shared -Wl,-soname,/bad/path/to/libblah.so.0 -o libblah.so.0.0 foo.o -nostdlib')
        r.Install('libblah*', '%(libdir)s/')

        # make sure that libraries in non-library paths provide with paths
        r.Create('notfound.c', contents='void notfound(void) { return ; }')
        r.Run('gcc -fPIC -g -c -o notfound.o notfound.c')
        r.Run('gcc -g -shared -Wl,-soname,libnotfound.so.0 -o libnotfound.so.0.0 notfound.o -nostdlib')
        r.Symlink('libnotfound.so.0.0', 'libnotfound.so.0')
        r.Symlink('libnotfound.so.0', 'libnotfound.so')
        r.Install('libnotfound*', '/opt/notfound/lib/')

        # make sure that consumers of non-library paths require with paths
        r.Create('findnot.c',
                 contents='void notfound(void); int main(void) { notfound() ; return 0;}')
        r.Make('findnot.o')
        r.Run('gcc -o findnot -Wl,-soname,findnot findnot.o -L. -lnotfound')
        r.Install('findnot', '%(bindir)s/')

        r.Create('/usr/libexec/conary/tags/blah', mode=0755)

        # make sure that libraries in non-library paths provide if requested
        r.Create('found.c', contents='void foo(void) { return ; }')
        r.Run('make CFLAGS=-g found.o')
        r.Run('ar r libfound.a found.o')
        r.Run('gcc -g -shared -Wl,-soname,libfound.so.0 -o libfound.so.0.0 foo.o -nostdlib')
        r.Install('libfound*', '/opt/found/lib/')
        r.SharedLibrary(subtrees='/opt/found/lib/')

        # make sure that symlinks provide their paths when requested
        r.Symlink('%(libdir)s/foobar/libfoo.so.0.0',
                  '%(libdir)s/symlink/libfoo.so.0.0')
        r.Provides('soname: libfoo.so.0',
                   '%(libdir)s/symlink/libfoo.so.0.0')

        # make sure that PIE executables do not provide their paths
        # when in bindirs (CNY-1128)
        r.addSource('smbumount', dir='%(bindir)s/', mode=0755)
        # nor tests (CNY-1138)
        r.Install('libfoo.so.0.0', '%(thistestdir)s/')

        # now make shlib handler happy with fake ldconfig
        r.Run('''
cat > true.c <<'EOF'
int main() {
    return 0;
}
EOF
        ''')
        r.Run('%(cc)s %(ldflags)s -static -o true true.c')
        r.Install('true', '%(essentialsbindir)s/ldconfig', mode=0755)
        r.ComponentSpec('runtime', '.*')
"""
        self.resetRepository()
        sonameRE = re.compile(r'soname: ELF[^/]*/lib.*\.so.*\.0')
        # CNY-699: export the filename of the symlink
        libfooSonameRE = re.compile(r'soname: ELF[^/]*/libfoo\.so\(')
        sonameDoubleSymlinkRE = re.compile(r'soname: ELF[^/]*/libfdsa2.so')
        sonamePathRE = re.compile(r'soname: ELF[^/]*/opt/notfound/lib.*/lib.*\.so.*\.0')
        pathSonameRE = re.compile(r'soname: ELF[^/]*/usr/.*/foobar/libfoo\.so.*\.0')
        symlinkSonameRE = re.compile(r'soname: ELF[^/]*/usr/.*/symlink/libfoo\.so.*\.0')
        # CNY-699: export both the soname and the filename of the file
        asdfSonameRE = re.compile(
            r'soname: ELF[^/]*/libfoo\.so\.0\(.*asdf[^)]*\)'+'\n'
            r'soname: ELF[^/]*/libfoo\.so\.0\.0\(')
        sillySonameRE = re.compile('soname: ELF[^/]*/libblah.so.0\(.*\)')
        findnotSonameRE = re.compile('soname:.*/usr/bin/findnot')
        smbumountSonameRe = re.compile('soname:.*/usr/bin/smbumount')
        testdirSonameRe = re.compile('soname:.*/var/conary/tests')

        self.logFilter.ignore('warning: EnforceSonameBuildRequirements: The following dependencies are not resolved within the package or in the system database:.*')
        trv = self.build(recipestr1, "TestProvides")
        repos = self.openRepository()
        prov = str(trv.getProvides())
        assert(prov.find('file: /bar') != -1)
        assert(prov.find('file: /blah') != -1)
        # CNY-930: automatically export paths in bindirs
        assert(prov.find('file: /usr/bin/findnot') != -1)
        assert(prov.find('file: /usr/bin/smbumount') != -1)
        # CNY-1721: but not directories
        assert(prov.find('file: /usr/libexec/conary') == -1)
        foundPaths = []
        found = 0
        if use.Arch.x86_64:
            libdir = '/usr/lib64'
        else:
            libdir = '/usr/lib'
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:runtime', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            foundPaths.append(path)
            prov = str(fileObj.provides())
            if path == '/foo':
                assert(prov.find('abi: ELF32(SysV x86)') != -1)
                found += 1
            elif path == util.joinPaths(libdir, 'libfoo.so'):
                assert(libfooSonameRE.search(prov))
                found += 1
            elif path == util.joinPaths(libdir, 'libnoversion.so'):
                # CNP-175 -- should be tagged as shlib
                assert 'shlib' in fileObj.tags
                found += 1
            elif path == util.joinPaths(libdir, 'libfoo.so.0.0'):
                assert(asdfSonameRE.search(prov))
                found += 1
            elif path == util.joinPaths(libdir, 'foobar/libfoo.so.0.0'):
                assert(pathSonameRE.search(prov))
                found += 1
            elif path == util.joinPaths(libdir, 'symlink/libfoo.so.0.0'):
                assert(symlinkSonameRE.search(prov))
                found += 1
            elif path == util.joinPaths(libdir, 'libblah.so.0.0'):
                assert(sillySonameRE.search(prov))
                found += 1
            elif path == '/opt/found/lib/libfound.so.0.0':
                assert(sonameRE.search(prov))
                found += 1
            elif path == '/opt/notfound/lib/libnotfound.so.0.0':
                assert(sonamePathRE.search(prov))
                found += 1
            elif path == '/usr/bin/findnot':
                assert(not findnotSonameRE.search(prov))
                found += 1
                # this requirement is removed by subtracting
                # local provisions from local requirements
                #req = str(trv.getRequires())
                #assert(sonamePathRE.search(req))
            elif path == '/usr/bin/smbumount':
                # PIE executables should not export their paths as
                # soname: deps (CNY-1128)
                assert(not smbumountSonameRe.search(prov))
                found += 1
            elif path == '/bar' or path == '/blah':
                assert(fileObj.flags.isPathDependencyTarget())
                found += 1
            elif 'libfdsa2.so' in path:
                assert(sonameDoubleSymlinkRE.search(prov))
                found += 1
        self.assertEqual(found, 14)
        found == 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:test', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            prov = str(fileObj.provides())
            assert(not testdirSonameRe.search(prov))
            found += 1
        assert(found >= 1)
        self.resetRepository()

    def testNonShlibDirSonameSymlinkLimits(self):
        # CNY-1108: incorrect library link dependency info
        recipestr = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('foo.c', contents='void foo(void) { return ; }')
        r.Run('make CFLAGS="-g -fPIC" foo.o')
        r.Run('gcc -g -shared -Wl,-soname,libfoo.so.0 -o libfoo.so.0.0 foo.o -nostdlib')
        r.Run('ln -s libfoo.so.0.0 libfoo.so')
        r.Install('libfoo*', '%(libdir)s/')
        r.Run('gcc -g -shared -Wl,-soname,libbar.so.0 -L. -lfoo -o libbar.so.0.0 foo.o -nostdlib')
        r.Install('libbar*', '%(libdir)s/')
        r.MakeDirs('%(libdir)s/foo')
        r.Symlink('%(libdir)s/libfoo.so.0.0', '%(libdir)s/foo/libfoo.so')
        r.MakeDirs('%(libdir)s/bar')
        r.Symlink('%(libdir)s/libbar.so.0.0', '%(libdir)s/bar/libbar.so')
        r.ComponentSpec('runtime', '.*')
"""
        trv = self.build(recipestr, "TestProvides")
        repos = self.openRepository()
        foundPaths = []
        found = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
            'foo:runtime', trv.getVersion(), trv.getFlavor(),
            withFiles=True):
            foundPaths.append(path)
            prov = str(fileObj.provides())
            req = str(fileObj.requires())
            if path == '/usr/lib/bar/libbar.so':
                # symlink in non-shlib path should not provide itself
                assert(prov == '')
                found += 1
            elif path == '/usr/lib64/bar/libbar.so':
                # symlink in non-shlib path should not provide itself
                assert(prov == '')
                found += 1
            elif path == '/usr/lib/libbar.so.0.0':
                # requirement does not falsely include wrong path
                assert('ELF32/usr/lib/foo/libfoo.so.0' not in req)
                assert('ELF32/libfoo.so.0' in req)
                # provide name and soname
                assert('ELF32/libbar.so.0.0(' in prov)
                assert('ELF32/libbar.so.0(' in prov)
                found += 1
            elif path == '/usr/lib64/libbar.so.0.0':
                # requirement does not falsely include wrong path
                assert('ELF64/usr/lib64/foo/libfoo.so.0' not in req)
                assert('ELF64/libfoo.so.0' in req)
                # provide name and soname
                assert('ELF64/libbar.so.0.0(' in prov)
                assert('ELF64/libbar.so.0(' in prov)
                found += 1
            elif path == '/usr/lib/libbar.so.0':
                # provide name of symlink
                assert('ELF32/libbar.so.0(' in prov)
                assert('ELF32/libbar.so.0.0(' not in prov)
                found += 1
            elif path == '/usr/lib64/libbar.so.0':
                # provide name of symlink
                assert('ELF64/libbar.so.0(' in prov)
                assert('ELF64/libbar.so.0.0(' not in prov)
                found += 1
            elif path == '/usr/lib/libfoo.so':
                # provides soname and name of file
                assert('ELF32/libfoo.so.0(' in prov)
                assert('ELF32/libfoo.so(' in prov)
                found += 1
            elif path == '/usr/lib64/libfoo.so':
                # provides soname and name of file
                assert('ELF64/libfoo.so.0(' in prov)
                assert('ELF64/libfoo.so(' in prov)
                found += 1
        assert(found == 4)
        self.resetRepository()


    @conary_test.installed_conarydb
    def testPythonProvides(self):
        """
        Test python: provides only, no requirements
        """
        recipestr1 = r"""
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/bin/python%(pyver)s', contents='\n'.join((
            '#!/bin/sh',
            'case "$@" in *sys.path*)',
            '  echo %(libdir)s/python%(pyver)s/site-packages',
            '  exit 0',
            '  ;;',
            'esac',
            'exec python "$@"',
            )), mode=0755)
        r.Create('/usr/bin/python2.5', contents='\n'.join((
            '#!/bin/sh',
            'case "$@" in *sys.path*)',
            '  echo %(libdir)s/python2.5/site-packages',
            '  exit 0',
            '  ;;',
            'esac',
            'exec python "$@"',
            )), mode=0755)
        r.Create('%(libdir)s/python%(pyver)s/site-packages/foo/four.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/foo/both.py')
        r.Create('%(libdir)s/python2.5/site-packages/foo/both.py')
        r.Create('%(libdir)s/python2.5/site-packages/foo/five.py')
        r.Create('%(libdir)s/xchat/plugins/python.so')
        # Test CNY-2050
        r.Create('%(libdir)s/python%(pyver)s/site-packages/badpython.py',
                 contents='#!/blah/bin/python',
                 mode=0755)
        # Test PEP 3149 interpreter so files
        r.Create('%(libdir)s/python%(pyver)s/site-packages/foo/ext.cpython-34m.so')
        # Test PEP 3147 interpreter pyc files
        r.Create('%(libdir)s/python%(pyver)s/site-packages/foo/__pycache__/bar.cpython-34m.pyc')
        r.ComponentSpec('runtime', '.*')
"""
        trv = self.build(recipestr1, "TestProvides",
            macros = dict(pyver = pythonVer))
        self.openRepository()
        prov = str(trv.getProvides())
        if use.Arch.x86_64:
            libsdir = 'lib64'
        else:
            libsdir = 'lib'
        assert prov.find('python: foo.four(%s %s)' % (pythonVer, libsdir)) != -1, prov
        both = " ".join(sorted([ pythonVer, "2.5" ]))
        assert prov.find('python: foo.both(%s %s)' % (both, libsdir)) != -1, prov
        assert prov.find('python: foo.five(2.5 %s)' % libsdir) != -1, prov
        assert prov.find('python: foo.ext(%s %s)' % (pythonVer, libsdir)) != -1, prov
        assert prov.find('python: foo.bar(%s %s)' % (pythonVer, libsdir)) != -1, prov

    def testPythonBootCrossProvides(self):
        """
        Test python: provides when cross-building with python:
        1) a python exists in %(destdir)s but it can't be run
        ...
        """
        recipestr = r"""
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/bin/python%(pyver)s', contents='\n'.join((
            '#!/bin/sh',
            # The error you get when trying to run a binary that does not
            # match the architecture or library set:
            'echo sh: /usr/bin/python%(pyver)s: No such file or directory >&2'
            'exit 127',
            )), mode=0755)
        r.Create('/usr/lib/python%(pyver)s/site-packages/foo.py', contents='\n'.join((
            '#!/usr/bin/python%(pyver)s',
            )), mode=0755)
        r.Create('/usr/lib/python%(pyver)s/asdf/bar.py', contents='\n'.join((
            '#!/usr/bin/python%(pyver)s',
            )), mode=0755)
        r.ComponentSpec('runtime', '.*\.py')
        r.Requires(bootstrapPythonFlags=('lib', '%(pyver)s'))
        r.Requires(bootstrapSysPath=['/usr/lib/python%(pyver)s/asdf'])
"""
        # exercise _getPythonVersionFromFlags
        self.mock(packagepolicy._dependency, '_getPythonVersionFromPath',
            lambda x, y, z: None)
        # make this be a cross-build
        self.cfg.buildFlavor.union(deps.parseFlavor('target:ppc'))
        self.logFilter.add()
        trv = self.build(recipestr, "TestProvides", logLevel=log.DEBUG,
            macros={'lib': 'lib', 'pyver' : pythonVer})
        self.logFilter.remove()
        prov = str(trv.getProvides())
        # test Provides having bootstrapPythonFlags and handling
        # not being able to run python
        assert(prov.find('python: foo') != -1)
        # test Provides having bootstrapSysPath
        assert(prov.find('python: bar') != -1)

    def testPythonCrossProvides(self):
        """
        Test python: provides when cross-building with python:
        ...
        2) a cross-python is installed to build against but can't be run
        """
        recipestr = r"""
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/lib/python%(pyver)s/site-packages/foo.py', contents='\n'.join((
            '#!/usr/bin/python%(pyver)s',
            )), mode=0755)
        r.Create('/usr/lib/python%(pyver)s/asdf/bar.py', contents='\n'.join((
            '#!/usr/bin/python%(pyver)s',
            )), mode=0755)
        r.ComponentSpec('runtime', '.*\.py')
        r.Requires(bootstrapPythonFlags=('lib', '%(pyver)s'))
        r.Requires(bootstrapSysPath=['/usr/lib/python%(pyver)s/asdf'])
"""
        # system python can't be run in a cross-build root -- the root
        # is there essentially only for headers and libraries
        import subprocess
        oldPopen = subprocess.Popen
        def mockPopen(*args, **kwargs):
            if ('python' in args[0][0]
                    or 'python' in kwargs.get('executable', '')):
                raise OSError(2, "No such file or directory")
            return oldPopen(*args, **kwargs)
        self.mock(subprocess, 'Popen', mockPopen)
        # make this be a cross-build
        self.cfg.buildFlavor.union(deps.parseFlavor('target:ppc'))
        self.logFilter.add()
        trv = self.build(recipestr, "TestProvides", logLevel=log.DEBUG,
            macros = dict(pyver = pythonVer))
        self.logFilter.remove()
        prov = str(trv.getProvides())
        self.assertIn('python: foo', prov)
        self.assertIn('python: bar', prov)


    def testPythonProvidesWithPthFile(self):
        """
        Test python: provides something that is included thanks to a .pth
        """
        recipestr1 = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(libdir)s/python%(pyver)s/site-packages/fdsjklf/blah.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/fdsjklf/__init__.py')
        r.Create('%(libdir)s/python%(pyver)s/site-packages/gtk.pth',
                 contents='fdsjklf')
        r.ComponentSpec('runtime', '.*')
"""
        trv = self.build(recipestr1, "TestProvides",
            macros = dict(pyver = pythonVer))
        prov = str(trv.getProvides())
        assert(prov.find('python: blah') != -1)
        assert(prov.find('python: fdsjklf') != -1)
        assert(prov.find('python: fdsjklf.blah') != -1)
        assert(prov.find('python: __init__') == -1)


    def testPythonProvidesWithDynloadFile(self):
        """
        Test python: provides something in a C-module-provided path
        """
        recipestr1 = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('%(libdir)s/python%(pyver)s/lib-dynload/blah.py')
        r.ComponentSpec('runtime', '.*')
"""
        trv = self.build(recipestr1, "TestProvides",
            macros = dict(pyver = pythonVer))
        prov = str(trv.getProvides())
        assert(prov.find('python: blah') != -1)


    def testPerlProvidesWithPerl(self):
        """
        Test perl: provides only, no requirements, with an embedded "perl"
        """
        recipestr1 = r"""
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('perl.c', contents=r'''
            #include <assert.h>
            #include <stdlib.h>
            #include <stdio.h>
            int main(void) {
                assert (getenv("LD_LIBRARY_PATH"));
                /* this is @INC */
                printf("/perl5\n");
                exit(0);
            }
            ''')
        r.Run('make CFLAGS=-g LDFLAGS=-Wl,-rpath,/foo perl')
        # RPATH gets turned into LD_LIBRARY_PATH
        r.Install('perl', '%(bindir)s/')
        r.Create('/perl5/foo/blah.pm')
        r.Create('/perl5/a.pl')
        r.Create('/perl5/b.ph')
        r.ComponentSpec('runtime', '.*')
"""
        trv = self.build(recipestr1, "TestProvides")
        prov = str(trv.getProvides())
        assert(prov.find('perl: foo::blah') != -1)
        assert(prov.find('perl: a') != -1)
        assert(prov.find('perl: b') != -1)

    def testPerlProvidesWithoutPerl(self):
        """
        Test perl: provides only, no requirements
        """
        recipestr1 = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # not %(libdir)s
        r.Create('VENDOR_PERL/foo/blah.pm')
        r.ComponentSpec('runtime', '.*')
""".replace('VENDOR_PERL', _findVendorPerl())
        trv = self.build(recipestr1, "TestProvides")
        prov = str(trv.getProvides())
        self.assertIn('perl: foo::blah', prov)

    def testEL5PathProvideRegexp(self):
        recipestr = """
class TestProvides(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        # Make sure that bindirs still get provided
        r.Create('/usr/bin/foo', mode=0755)
        # ensure that providing directories works
        r.MakeDirs('/etc/ld.so.conf.d')
        r.ExcludeDirectories(exceptions='/etc/ld.so.conf.d')
        # Leave out some files (e.g. /etc/aliases) to make sure that this whole
        # string just works everywhere and will provide what is specified
        # and not otherwise.  A string like this needs to be in the factory
        # for any capsule platform that depends on file: dependencies
        for path in (
            '/etc/mime.types',
            '/etc/pam.d/remote',
            '/etc/pam.d/system-auth',
            '/etc/redhat-release',
            '/etc/termcap',
            '/lib/security/pam_loginuid.so',
            '/usr/lib/eclipse/configuration/config.ini',
            '/usr/lib/eclipse/plugins/org.eclipse.swt.gtk.linux.x86_3.2.1.v3235.jar',
            '/usr/lib/gcc/i386-redhat-linux/4.1.1/libgcj.spec',
            '/usr/lib/gcj-4.1.1/libjvm.so',
            '/usr/lib/libgcj.so.7rh',
            '/usr/lib/libstdc++.so.6',
            '/usr/lib/libz.so',
            '/usr/lib/lsb/install_initd',
            '/usr/lib/lsb/remove_initd',
            '/usr/lib/news/lib/innshellvars.pl',
            '/usr/lib/perl5/vendor_perl/5.8.8/i386-linux-thread-multi',
            '/usr/share/desktop-menu-patches/gnome-gdmsetup.desktop',
            '/usr/share/gnome-screensaver/lock-dialog-system.glade',
            '/usr/share/magic.mime',
            '/usr/share/openldap/migration/migrate_common.ph',
            '/usr/share/X11/XKeysymDB'):
            r.Create(path)
        r.Provides('file',
            '(/etc/(aliases|cron.d|init.d|ld.so.conf.d|mime.types|'
                    'pam.d/(remote|system-auth)|redhat-release|termcap)|'
             '/lib.*/security/.*|'
             '/usr/(lib.*/(eclipse/(configuration/config.ini|'
                                   'plugins/org\.eclipse\.swt\..*\.jar)|'
                          'gcc/.*/libgcj\.spec|'
                          'gcj-.*/libjvm.so|libgcj\.so\.7rh|'
                          'libstdc\+\+\.so\.6|libz\.so|'
                          'lsb/install_initd|lsb/remove_initd|'
                          'news/lib/innshellvars\.pl|'
                          'perl5/vendor_perl/.*/i386-linux-thread-multi|'
                          'python2\.4|python2\.4/site-packages)|'
                   'share/(desktop-menu-patches/gnome-gdmsetup\.desktop|'
                          'gnome-screensaver/lock-dialog-system\.glade|'
                          'magic\.mime|openldap/migration/migrate_common\.ph|'
                          'X11/XKeysymDB)))')
        r.ComponentSpec('runtime', '.*')

"""
        trv = self.build(recipestr, "TestProvides")
        prov = str(trv.getProvides())
        prov = [x for x in prov.split('\n') if x.startswith('file:')]
        expectedList = [
            'file: /etc/ld.so.conf.d',
            'file: /etc/mime.types',
            'file: /etc/pam.d/remote',
            'file: /etc/pam.d/system-auth',
            'file: /etc/redhat-release',
            'file: /etc/termcap',
            'file: /lib/security/pam_loginuid.so',
            'file: /usr/bin/foo',
            'file: /usr/lib/eclipse/configuration/config.ini',
            'file: /usr/lib/eclipse/plugins/org.eclipse.swt.gtk.linux.x86_3.2.1.v3235.jar',
            'file: /usr/lib/gcc/i386-redhat-linux/4.1.1/libgcj.spec',
            'file: /usr/lib/gcj-4.1.1/libjvm.so',
            'file: /usr/lib/libgcj.so.7rh',
            'file: /usr/lib/libstdc++.so.6',
            'file: /usr/lib/libz.so',
            'file: /usr/lib/lsb/install_initd',
            'file: /usr/lib/lsb/remove_initd',
            'file: /usr/lib/news/lib/innshellvars.pl',
            'file: /usr/lib/perl5/vendor_perl/5.8.8/i386-linux-thread-multi',
            'file: /usr/share/X11/XKeysymDB',
            'file: /usr/share/desktop-menu-patches/gnome-gdmsetup.desktop',
            'file: /usr/share/gnome-screensaver/lock-dialog-system.glade',
            'file: /usr/share/magic.mime',
            'file: /usr/share/openldap/migration/migrate_common.ph']
        self.assertEqual(prov, expectedList)


class OwnershipTest(rephelp.RepositoryHelper):
    def testOwnershipTest1(self):
        """
        Test requirements
        """
        recipestr1 = """
class TestOwnership(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/foo')
        r.Ownership('foo', 'bar', '/foo')
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr1, "TestOwnership")
        self.logFilter.remove()
        # get the records we want, ignore the rest
        self.logFilter.ignore('^info:')
        self.logFilter.ignore(r'^. deleting')
        self.logFilter.compare([])

        recipestr2 = """
class TestOwnership(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.macros.foo = 'foo'
        r.macros.bar = 'bar'
        r.Create('/foo')
        r.Ownership('%(foo)s', '%(bar)s', '/foo')
"""
        self.reset()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipestr2, "TestOwnership")
        self.logFilter.remove()
        self.logFilter.ignore('^info:')
        self.logFilter.ignore(r'^. deleting')
        self.logFilter.compare([])


class UtilizeTest(rephelp.RepositoryHelper):
    def testUtilize(self):
        recipestr1 = r"""
class TestUtilize(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.macros.userMacro = 'nobody'
        r.Create('%(bindir)s/foo', contents='foo', mode=0755)
        r.UtilizeUser('%(userMacro)s', '%(bindir)s/foo')
        r.UtilizeUser('%(userMacro)s', '.*')
        r.UtilizeUser('nobody2', '%(bindir)s/foo')
        r.UtilizeGroup('%(userMacro)s', '%(bindir)s/foo')
        r.UtilizeGroup('nobody2', '%(bindir)s/foo')
"""
        built, d = self.buildRecipe(recipestr1, "TestUtilize")
        repos = self.openRepository()
        requires = str(repos.getTrove(*repos.findTrove(None, built[0])[0]).getRequires())
        assert('userinfo: nobody' in requires)
        assert('userinfo: nobody2' in requires)
        assert('groupinfo: nobody' in requires)
        assert('groupinfo: nobody2' in requires)

class FlavoredLibdirsTest(rephelp.RepositoryHelper):
    def testFlavoredLibdirsTest1(self):
        recipestr1 = """
class TestFlavoredLibdirs(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/lib/foo')
"""
        trv = self.build(recipestr1, "TestFlavoredLibdirs")
        if use.Arch.x86:
            flavor = use.Arch.getCurrentArch()._toDependency()
        elif use.Arch.x86_64:
            # XXX this might not be the correct behavior...
            flavor = deps.Flavor()
        else:
            raise NotImplementedError('edit test for this arch')
        assert(trv.getFlavor() == flavor)

    def testFlavoredLibdirsTest2(self):
        if not use.Arch.bits64:
            # this test is only valid on 64-bit platforms
            return
        recipestr1 = """
class TestFlavoredLibdirs(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/lib64/foo')
"""
        trv = self.build(recipestr1, "TestFlavoredLibdirs")
        flavor = use.Arch.getCurrentArch()._toDependency()
        assert(trv.getFlavor() == flavor)

    def testFlavoredLibdirsTest3(self):
        recipestr1 = """
class TestFlavoredLibdirs(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()
    def setup(r):
        r.Create('/usr/lib/python%(pyver)s/foo')
        r.Create('/usr/lib/python3.6/lib/foo')
"""
        trv = self.build(recipestr1, "TestFlavoredLibdirs",
            macros = dict(pyver = pythonVer))
        assert(trv.getFlavor().isEmpty())



class NonUTF8FilenamesTest(rephelp.RepositoryHelper):
    def testNonUTF8Filenames(self):
        recipestr1 = """
class TestNonUTF8Filenames(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/enroul\xe9.logo')
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.build,
                          recipestr1, "TestNonUTF8Filenames")


class BadFilenamesTest(rephelp.RepositoryHelper):
    def testBadFilenames(self):
        recipestr1 = r"""
class TestBadFilenames(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/foo\nbar')
"""
        self.reset()
        self.assertRaises(policy.PolicyError, self.build,
                          recipestr1, "TestBadFilenames")



class ByDefaultTest(rephelp.RepositoryHelper):
    def testByDefault(self):
        recipestr1 = r"""
class TestByDefault(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/bar')
        r.ByDefault(exceptions=':runtime')
"""
        self.resetRoot()
        (built, d) = self.buildRecipe(recipestr1, "TestByDefault")
        self.updatePkg(self.workDir, 'test', '0')
        self.assertRaises(OSError, os.stat, self.workDir+'/bar')
        recipestr2 = r"""
class TestByDefault(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/bar')
        r.ByDefault(exceptions='test:runtime')
"""
        self.resetRoot()
        (built, d) = self.buildRecipe(recipestr2, "TestByDefault")
        self.updatePkg(self.workDir, 'test', '0')
        self.assertRaises(OSError, os.stat, self.workDir+'/bar')



class EnforceCMakeCacheBuildRequirementsTest(rephelp.RepositoryHelper):
    def testEnforceCMakeCacheBuildRequirements(self):
        recipeProv = r"""
class TestProv(PackageRecipe):
    name = 'testprov'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/usr/bin/ar', mode=0755)
        # Create :devel, :lib, :devellib for CNP-105
        r.Create('foo.c', contents='void foo(void) { return ; }')
        r.Run('make CFLAGS="-g -fPIC" foo.o')
        r.Run('gcc -g -shared -Wl,-soname,libfoo.so.0 -o libfoo.so.0.0 foo.o -nostdlib')
        r.Install('libfoo.so.0.0', '/usr/lib/')
        r.Symlink('libfoo.so.0.0', '/usr/lib/libfoo.so.0')
        r.Symlink('libfoo.so.0.0', '/usr/lib/libfoo.so')
        r.FixupMultilibPaths(exceptions='.*')
        r.Create('%(includedir)s/libfoo.h')
"""
        recipeReq0 = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/bin/blah', mode=0755)
        r.addSource('CMakeCache.txt')
"""
        self.resetRoot()
        (built, d) = self.buildRecipe(recipeProv, "TestProv")
        # Capture output, we get an ldconfig warning otherwise
        self.logFilter.add()
        self.updatePkg(self.workDir, 'testprov', '0')
        self.logFilter.remove()
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipeReq0, "TestReq", logLevel=log.DEBUG)
        self.logFilter.remove()
        messages = (
            'warning: EnforceCMakeCacheBuildRequirements: path /usr/bin/ar suggests buildRequires: testprov:runtime',
            'warning: EnforceCMakeCacheBuildRequirements: path /usr/lib/libfoo.so suggests buildRequires: testprov:devel',
            "warning: EnforceCMakeCacheBuildRequirements: Probably add to buildRequires: ['testprov:devel', 'testprov:runtime']")
        for message in messages:
            assert message in self.logFilter.records, 'missing '+message



class EnforceConfigLogBuildRequirementsTest(rephelp.RepositoryHelper):
    def testEnforceConfigLogBuildRequirements(self):
        recipeReq0 = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/bin/blah', mode=0755)
        r.Create('config.log', contents='''configure:1234: found /bin/foo
configure:1235: found /usr/bin/g77''')
"""
        recipeReq1 = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create('/bin/blah', mode=0755)
        r.Create('config.log', contents='''configure:1234: found /bin/foo
configure:1235: found /usr/bin/g77
configure:1236: found /bin/blah''')
"""
        self.resetRoot()
        self.addComponent("testprov:runtime", "1", fileContents = [
            ('/bin/foo',     rephelp.RegularFile(contents="", perms=0o755)),
            ('/usr/bin/g77', rephelp.RegularFile(contents="", perms=0o755)),
        ])
        self.updatePkg('testprov:runtime')
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipeReq0, "TestReq", logLevel=log.DEBUG)
        self.logFilter.remove()
        assert("warning: EnforceConfigLogBuildRequirements: Probably add to buildRequires: ['testprov:runtime']" in self.logFilter.records)
        # make sure that the unlikely g77 requirement is ignored
        assert(not [x for x in self.logFilter.records if "g77" in x])
        self.updatePkg(self.workDir, 'testreq', '0')
        # no recursive buildRequires!
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipeReq1, "TestReq", logLevel=log.DEBUG)
        self.logFilter.remove()
        assert(not [x for x in self.logFilter.records if "testreq:runtime" in x])

        recipeReq2 = r"""
class TestFortReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('config.log', contents='configure:1235: found /usr/bin/g77')
        r.Create('configure.ac', contents='AC_PROG_F77')
"""
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipeReq2, "TestFortReq", logLevel=log.DEBUG,
                                      d = d)
        self.logFilter.remove()
        # make sure that the g77 requirement is honored because of AC_PROG_F77
        assert([x for x in self.logFilter.records if "testprov:runtime" in x])


    def testConfigLogStanzas(self):
        recipestr = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create('/opt/ignoreme')
        r.Create('config.log', contents='''
configure:1234: found /bin/foo
configure:1235: found /usr/bin/g77
configure:1236: found /bin/blah
configure:3481: checking for sys/wait.h that is POSIX.1 compatible
configure:3512: gcc -c -O2 -march=i686 -g -D_FORTIFY_SOURCE=2 -fstack-protector  conftest.c >&5
configure:3518: $? = 0
configure:3522: test -z
                        || test ! -s conftest.err
configure:3525: $? = 0
configure:3528: test -s conftest.o
configure:3531: $? = 0
configure:3542: result: yes
configure:3632: checking for sys/types.h
configure:3648: gcc -c -O2 -march=i686 -g -D_FORTIFY_SOURCE=2 -fstack-protector  conftest.c >&5
configure:3654: $? = 0
configure:3658: test -z
                        || test ! -s conftest.err
configure:3661: $? = 0
configure:3664: test -s conftest.o
configure:3667: $? = 0
configure:3678: result: yes
configure:3877: checking assert.h usability
configure:3889: gcc -c -O2 -march=i686 -g -D_FORTIFY_SOURCE=2 -fstack-protector  conftest.c >&5
configure:3895: $? = 0
configure:3899: test -z
                         || test ! -s conftest.err
configure:3902: $? = 0
configure:3905: test -s conftest.o
configure:3908: $? = 0
configure:3918: result: yes
configure:3922: checking assert.h presence
configure:3932: gcc -E  conftest.c
configure:3938: $? = 0
configure:3958: result: yes
configure:3993: checking for assert.h
configure:4000: result: yes
configure:3993: checking for broken.h
configure:4000: result: no
configure:3463: checking for ignore.h
configure:7645: checking for asdf.h
configure:3648: gcc -c -O2 -I/usr/include/asdf  conftest.c >&5
configure:3465: result: yes
configure:2345: checking for /bin/sought
configure:6543: result: yes
configure:4441: checking for egrep
configure:4519: result: /bin/grep -E
configure:4535: checking for ld used by gcc
configure:4602: result: /usr/bin/ld
configure:2973: checking for suffix of executables
configure:2980: gcc -o conftest -O2 -g -D_FORTIFY_SOURCE=2 -fstack-protector  -g -O1  conftest.c  >&5
configure:2983: $? = 0
configure:3007: result:
configure:3456: checking for two spaces at the end of a result line (CNP-128)
configure:3478: result:

''')
        # Might as well collect samples here of entire real-life config.log
        # files...
        r.addSource('CNP-128.config.log', dest='CNP-128/config.log')
"""
        self.resetRoot()
        self.addComponent("testprov:runtime", "1", fileContents = [
            ('/bin/foo',     rephelp.RegularFile(contents="", perms=0o755)),
            ('/usr/bin/g77', rephelp.RegularFile(contents="", perms=0o755)),
        ])
        if use.Arch.x86_64:
            lib = 'lib64'
        else:
            lib = 'lib'
        self.addComponent("testprov:devel", "1", fileContents = [
            ('/usr/include/asdf/asdf.h', rephelp.RegularFile(contents="")),
        ])
        self.addComponent("testprov:devellib", "1", fileContents = [
            ('/usr/%s/asdf.a'%lib, rephelp.RegularFile(contents="")),
        ])
        self.addComponent("wait:devel", "1", fileContents = [
            ('/usr/include/sys/wait.h', rephelp.RegularFile(contents="")),
        ])
        self.addComponent("types:devel", "1", fileContents = [
            ('/usr/include/sys/types.h', rephelp.RegularFile(contents="")),
        ])
        self.addComponent("assert:devel", "1", fileContents = [
            ('/usr/include/assert.h', rephelp.RegularFile(contents="")),
        ])
        self.addComponent("broken:devel", "1", fileContents = [
            ('/usr/include/broken.h', rephelp.RegularFile(contents="")),
        ])
        self.addComponent("sought:runtime", "1", fileContents = [
            ('/bin/sought', rephelp.RegularFile(contents="", perms=0o755)),
        ])
        self.addComponent("grep:runtime", "1", fileContents = [
            ('/bin/grep', rephelp.RegularFile(contents="", perms=0o755)),
        ])
        self.addComponent("ld:runtime", "1", fileContents = [
            ('/usr/bin/ld', rephelp.RegularFile(contents="", perms=0o755)),
        ])
        self.updatePkg([
            'testprov:runtime', 'testprov:devel', 'testprov:devellib',
            'wait:devel', 'types:devel', 'assert:devel', 'broken:devel',
            'sought:runtime', 'grep:runtime', 'ld:runtime',
        ])

        reportedRealReqs = set()
        realUA = packagepolicy.reportExcessBuildRequires.updateArgs
        self.mock(packagepolicy.reportExcessBuildRequires, 'updateArgs',
                  lambda *args:
                    mockedSaveArgSet(args[0], realUA, reportedRealReqs, *args[1:]))
        self.buildRecipe(recipestr, "TestReq")

        self.assertEqual(reportedRealReqs,
                          set(['testprov:runtime', 'testprov:devel',
                               'types:devel', 'assert:devel',
                               'sought:runtime', 'grep:runtime', 'ld:runtime',
                              ]))



    def testDestDirInRPATH(self):
        recipeRPATH = r"""
class TestRPATH(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('foo.c', contents='int main(void) { return 0; }\n')
        r.Run('gcc -o foo foo.c -Wl,-rpath,%(destdir)s/foo -Wl,-rpath,/bar')
        r.Run('gcc -o foo2 foo.c -Wl,-rpath,/bar:/tmp/foo')
        r.Run('gcc -o foo3 foo.c -Wl,-rpath,/bar -Wl,-rpath,/var/tmp/foo')
        r.Run('gcc -o foo4 foo.c -Wl,-rpath,/bar')
        r.Install('foo', 'foo2', 'foo3', 'foo4', '%(bindir)s/', mode=0755)
"""
        try:
            self.buildRecipe(recipeRPATH, "TestRPATH")
        except Exception as err:
            # foo4 is okay
            assert('/usr/bin/foo4' not in str(err))

            template = 'CheckDestDir: file %s has illegal RPATH %s'
            msgs = [('/usr/bin/foo', self.cfg.buildPath),
                    ('/usr/bin/foo2', '/tmp/foo'),
                    ('/usr/bin/foo3', '/var/tmp/foo')]
            lines = str(err).split('\n')
            for msg in msgs:
                msg = template % msg
                found = False
                for line in lines:
                    if line.startswith(msg):
                        found = True
                        break
                assert(found)



    def testDoubleLeadingSlashRPATH(self):
        'CNY-3425'
        recipeRPATH = r"""
class TestRPATH(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Provides(sonameSubtrees=['/double/slash'])
        r.Requires(sonameSubtrees=['/double/slash'])
        r.Create('altfound.c', contents='void altfound(void) { return ; }')
        r.Run('gcc -fPIC -g -c -o altfound.o altfound.c')
        r.Run('gcc -g -shared -Wl,-soname,libaltfound.so.0 -o libaltfound.so.0.0 altfound.o -nostdlib')
        r.Symlink('libaltfound.so.0.0', 'libaltfound.so.0')
        r.Symlink('libaltfound.so.0', 'libaltfound.so')
        r.Create('foo.c', contents='int main(void) { return 0; }\n')
        r.Run('gcc -o foo foo.c -L. -laltfound -Wl,-rpath,//double/slash')
        r.Install('libaltfound*', '/double/slash/')
        r.Install('foo', '%(bindir)s/', mode=0755)
"""
        trv = self.build(recipeRPATH, "TestRPATH")
        repos = self.openRepository()
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trv.getName(), trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            req = str(fileObj.requires())
            if path == '/usr/bin/foo':
                assert('double/slash/libaltfound' not in req)
        self.resetRepository()



class EnforceLocalizationBuildRequirementsTest(rephelp.RepositoryHelper):
    def testEnforceLocalizationBuildRequirements(self):
        recipestr = r"""
class Test(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('foo/POTFILES.in', mode=0644)
        r.Create('/opt/ignoreme')
"""
        self.resetRoot()
        self.logFilter.add()
        self.buildRecipe(recipestr, "Test", logLevel=log.DEBUG)
        self.logFilter.remove()
        message = "warning: EnforceLocalizationBuildRequirements: missing buildRequires ['gettext:runtime', 'intltool:runtime'] for file foo/POTFILES.in"
        assert message in self.logFilter.records, 'missing '+message



class EnforcePerlBuildRequirementsTest(rephelp.RepositoryHelper):
    def testEnforcePerlBuildRequirements(self):
        recipeProv = r"""
class TestProv(PackageRecipe):
    name = 'perl'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create('/usr/bin/perl', mode=0755,
                 contents='echo %(libdir)s/perl5/5.8.7/i386-linux-thread-multi')
        r.Create('%(libdir)s/perl5/5.8.7/i386-linux-thread-multi/POSIX.pm',
                 contents='package POSIX;')
"""
        recipe = r"""
class testperl(PackageRecipe):
    name = 'testperl'
    version = '1'

    clearBuildReqs()
    buildRequires = ['perl:runtime']

    def setup(r):
        r.Create('/usr/bin/foo',
                 mode=0755,
                 contents='#!/usr/bin/perl\nuse POSIX;')
"""

        self.resetRoot()
        (built, d) = self.buildRecipe(recipeProv, "TestProv")
        self.updatePkg(self.workDir, 'perl', '1')
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipe, "testperl")
        self.logFilter.remove()
        assert("warning: EnforcePerlBuildRequirements: The following dependencies are not resolved within the package or in the system database: ['perl: POSIX']" not in self.logFilter.records)
        assert("warning: EnforcePerlBuildRequirements: add to buildRequires: ['perl:lib']" not in self.logFilter.records)
        assert(not self.logFilter.records)


class EnforceFlagRequirementsTest(rephelp.RepositoryHelper):
    def testEnforceFlagRequirements(self):
        recipeProv = r"""
class TestProv(PackageRecipe):
    name = 'ifeelused'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/use/ifeelused')
"""
        recipe = r"""
class test(PackageRecipe):
    name = 'test'
    version = '1'

    clearBuildReqs()

    def setup(r):
        if Use.ifeelused:
            pass
        r.Create('/usr/bin/foo',
                 mode=0755)
"""

        self.resetRoot()
        (built, d) = self.buildRecipe(recipeProv, "TestProv")
        self.updatePkg(self.workDir, 'ifeelused', '1')
        thisFlagDir = self.workDir + '/etc/conary/use'
        self.cfg.useDirs.append(thisFlagDir)
        use.Use._addFlag('ifeelused', path='/etc/conary/use/ifeelused')
        self.logFilter.add()
        (built, d) = self.buildRecipe(recipe, "test")
        self.logFilter.remove()
        assert('warning: EnforceFlagBuildRequirements: flag ifeelused missing build requirement ifeelused:config' in self.logFilter.records)



class EnforceSonameBuildRequirementsTest(rephelp.RepositoryHelper):
    def testEnforceSonameBuildRequirements(self):
        recipeProvShared = r"""
class TestProvShared(PackageRecipe):
    name = 'shlib'
    version = '0'
    clearBuildReqs()

    def setup(r):
        # to ensure that shlibs do not confuse things
        r.Create('shlib.c', contents='void shlib(void) { return ; }')
        r.Run('gcc -fPIC -g -c -o shlib.o shlib.c')
        r.Run('gcc -g -shared -Wl,-soname,libshlib.so.0 -o libshlib.so.0.0 shlib.o -nostdlib')
        r.Symlink('libshlib.so.0.0', 'libshlib.so.0')
        r.Symlink('libshlib.so.0', 'libshlib.so')
        r.Install('libshlib*', '/%(libdir)s/')
        # now make shlib handler happy with fake ldconfig
        r.Run('''
cat > true.c <<'EOF'
int main() {
    return 0;
}
EOF
        ''')
        r.Run('%(cc)s %(ldflags)s -static -o true true.c')
        r.Install('true', '%(essentialsbindir)s/ldconfig', mode=0755)
        r.Create('%(prefix)s/include/shlib.h')
"""

        recipeReqShlib= r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()
    #buildRequires = ['shlib:devel']

    def setup(r):
        r.Create('useshlib.c', contents='')
        r.Create('useshlib.c', contents='int main(void) { shlib() ; return ;}')
        r.Make('useshlib.o')
        r.Run('%%(cc)s -o useshlib useshlib.o -L%s%%(libdir)s -lshlib' %r.cfg.root)
        r.Install('useshlib', '%(bindir)s/')
        r.Requires(exceptDeps=r'soname: ELF.*/libc\.so\..*')
"""

        self.resetRoot()
        self.buildRecipe(recipeProvShared, "TestProvShared")
        self.updatePkg(self.workDir, 'shlib', '0')
        self.logFilter.add()
        self.buildRecipe(recipeReqShlib, "TestReq")
        self.logFilter.remove()
        assert("warning: EnforceSonameBuildRequirements: add to buildRequires: ['shlib:devel']" in self.logFilter.records)
        self.logFilter.clear()
        self.logFilter.add()
        self.buildRecipe(recipeReqShlib.replace('#buildR', 'buildR'), "TestReq")
        self.logFilter.remove()
        assert("warning: EnforceSonameBuildRequirements: add to buildRequires: ['shlib:devel']" not in self.logFilter.records)




class LocalLogFilter:
    # variant that does not filter out what is written, since in this
    # case the subclass actually depends on getting these messages!
    def __init__(self):
        self.records = []

    def clear(self):
        from conary.lib import log
        self.records = []
        log.logger.removeFilter(self)

    def filter(self, record):
        msg = record.msg
        self.records.append(msg % record.args)
        # WOW, what a hack...
        if msg.startswith('+ make') or msg.startswith('+ gcc'):
            return True
        return False

    def ignore(self, regexp):
        self.ignorelist.append(re.compile(regexp))

    def add(self):
        from conary.lib import log
        self.records = []
        log.logger.addFilter(self)

    def remove(self):
        from conary.lib import log
        log.logger.removeFilter(self)


# need a reference now so we can mock later
loggerStreamLogWriter = logger.StreamLogWriter
class QuietTheScreen(loggerStreamLogWriter):
    def __init__(self, *args):
        loggerStreamLogWriter.__init__(self, *args)
        self.data.hideLog = True
    @logger.callable
    def pushDescriptor(self, descriptor):
        pass
    @logger.callable
    def popDescriptor(self, descriptor):
        pass


class EnforceStaticLibBuildRequirementsTest(rephelp.RepositoryHelper):
    def __init__(self, *args, **kw):
        rephelp.RepositoryHelper.__init__(self, *args, **kw)
        self.logFilter = LocalLogFilter()

    def testEnforceStaticLibBuildRequirements(self):
        recipeProvStatic = r"""
class TestProvStatic(PackageRecipe):
    name = 'asdf'
    version = '0'
    clearBuildReqs()

    def setup(r):
        # completely fake static lib
        r.Create('%(libdir)s/libasdf.a')
        r.Create('%(prefix)s/include/asdf.h')
"""

        recipeProvShared = r"""
class TestProvShared(PackageRecipe):
    name = 'shlib'
    version = '0'
    clearBuildReqs()

    def setup(r):
        # to ensure that shlibs do not confuse things
        r.Create('shlib.c', contents='void shlib(void) { return ; }')
        r.Run('gcc -fPIC -g -c -o shlib.o shlib.c')
        r.Run('gcc -g -shared -Wl,-soname,libshlib.so.0 -o libshlib.so.0.0 shlib.o -nostdlib')
        r.Symlink('libshlib.so.0.0', 'libshlib.so.0')
        r.Symlink('libshlib.so.0', 'libshlib.so')
        r.Install('libshlib*', '/%(libdir)s/')
        # now make shlib handler happy with fake ldconfig
        r.Run('''
cat > true.c <<'EOF'
int main() {
    return 0;
}
EOF
        ''')
        r.Run('%(cc)s %(ldflags)s -static -o true true.c')
        r.Install('true', '%(essentialsbindir)s/ldconfig', mode=0755)
        r.Create('/usr/include/shlib.h')
"""

        recipeProvStaticDup = r"""
class TestProvStatic(PackageRecipe):
    name = 'asdup'
    version = '0'
    clearBuildReqs()

    def setup(r):
        # completely fake static lib with same name as package asdf
        r.Create('/%(lib)s/libasdf.a')
        r.Create('%(prefix)s/include/asdup.h')
"""

        recipeReqTerminal = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('%(cc)s', contents='#!/bin/sh\nexit 0', mode=0755)
        r.Environment('PATH', '.:/bin:/usr/bin')
        r.Run('%(cc)s -lasdf')
        r.Create('/opt/ignoreme')
"""
        recipeReqConfigLog = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('config.log', contents='''
configure:1234: checking for blah in -lasdf
configure:1236: %(cc)s -o conftest -O2 -g -lasdf >&5
configure:2345: $? = 0
configure:2346: test -z
                        || test ! -s conftest.err
configure:3465: $? = 0
configure:2344: test -s conftest
configure:2345: $? = 0
configure:3465: result: yes
''')
        r.Create('/opt/ignoreme')
"""

        recipeReqConfigLogOnlyShared= r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    buildRequires = ['shlib:devel']

    def setup(r):
        r.Create('config.log', contents='''
configure:1234: checking for blah in -lshlib
configure:1236: %(cc)s -o conftest -O2 -g -lshlib >&5
configure:2345: $? = 0
configure:2346: test -z
                        || test ! -s conftest.err
configure:3465: $? = 0
configure:2344: test -s conftest
configure:2345: $? = 0
configure:3465: result: yes
''')
        r.Create('/opt/ignoreme')
"""

        recipeReqAlreadyRequired = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()
    buildRequires = ['asdf:devel']

    def setup(r):
        r.Run('echo %(cc)s -lasdf')
        r.Create('/opt/ignoreme')
"""

        recipeReqSurrounded = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('useshlib.c', contents='')
        r.Create('useshlib.c', contents='int main(void) { shlib() ; return ;}')
        r.Make('useshlib.o')
        r.Run('%%(cc)s -o useshlib useshlib.o -L%s%%(libdir)s -lshlib' %r.cfg.root)
        r.Install('useshlib', '%(bindir)s/')
        r.Create('make', contents='echo %(cxx)s -lshlib -lasdf -o blah\nexit 0', mode=0755)
        r.Run('./make')
        del r.EnforceSonameBuildRequirements
"""

        recipeReqInternal = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        # completely fake static lib within package
        r.Create('%(libdir)s/libinternal.a')
        r.Run('echo %(cc)s -lasdf -linternal')
"""

        recipeReqInternalUninstalled = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        # completely fake static lib within package
        r.Create('lib/libinternal.a')
        r.Run('echo %(cc)s -lasdf -L%(builddir)s/lib -linternal')
        r.Create('/opt/ignoreme')
"""

        recipeReqMissing = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        # this line should be ignored because initial pattern match fails
        r.Run('echo checking for asdf: -lasdf')
        # this line should be ignored because libnonesuch is not found
        r.Run('echo ld -lnonesuch -lshlib -o blah')
        # this line should not produce duplicate output
        r.Run('echo ld -lnonesuch')
        r.Create('/opt/ignoreme')
"""

        recipeReqUnmanaged = r"""
class TestReq(PackageRecipe):
    name = 'testreq'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('%(cc)s', contents='#!/bin/sh\nexit 0', mode=0755)
        r.Environment('PATH', '.:/bin:/usr/bin')
        r.Run('%(cc)s -lfoo')
        r.Create('/opt/ignoreme')
"""

        self.resetRoot()
        self.buildRecipe(recipeProvStatic, "TestProvStatic")
        self.updatePkg(self.workDir, 'asdf', '0')
        self.buildRecipe(recipeProvShared, "TestProvShared")
        self.updatePkg(self.workDir, 'shlib', '0')
        self.buildRecipe(recipeProvStaticDup, "TestProvStatic")

        def buildOneRecipe(recipeText):
            os.chdir(self.workDir)
            self.newpkg('testreq')
            os.chdir('testreq')
            file('testreq.recipe', 'w').write(recipeText)
            repos = self.openRepository()
            self.logFilter.add()
            log.setVerbosity(log.DEBUG)
            oldStreamLogWriter = logger.StreamLogWriter
            try:
                logger.StreamLogWriter = QuietTheScreen
                cook.cookItem(repos, self.cfg, 'testreq.recipe', logBuild=True)
            finally:
                logger.StreamLogWriter = oldStreamLogWriter
            # Debugging is far easier without QuietTheScreen
            #cook.cookItem(repos, self.cfg, 'testreq.recipe', logBuild=True)

            self.logFilter.remove()


        if use.Arch.x86_64:
            libdir = '/usr/lib64'
            elibdir = '/lib64'
        else:
            libdir = '/usr/lib'
            elibdir = '/lib'

        buildOneRecipe(recipeReqTerminal)
        assert("+ EnforceStaticLibBuildRequirements: Add 'asdf:devel' to buildRequires for -lasdf (%s/libasdf.a)" %libdir in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['asdf:devel']" in self.logFilter.records)

        buildOneRecipe(recipeReqConfigLog)
        assert("+ EnforceStaticLibBuildRequirements: Add 'asdf:devel' to buildRequires for -lasdf (%s/libasdf.a)" %libdir in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['asdf:devel']" in self.logFilter.records)

        buildOneRecipe(recipeReqConfigLogOnlyShared)
        # CNP-132
        assert("+ EnforceStaticLibBuildRequirements: No files found matching -lshlib: possible missing buildRequires" not in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['shlib:devel']" not in self.logFilter.records)

        buildOneRecipe(recipeReqAlreadyRequired)
        assert("+ EnforceStaticLibBuildRequirements: Add 'asdf:devel' to buildRequires for -lasdf (%s/libasdf.a)" %libdir not in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['asdf:devel']" not in self.logFilter.records)

        buildOneRecipe(recipeReqSurrounded)
        assert("+ EnforceStaticLibBuildRequirements: Add 'asdf:devel' to buildRequires for -lasdf (%s/libasdf.a)" %libdir in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['asdf:devel']" in self.logFilter.records)
        # note: no mention of "shlib"
        shlibRe = re.compile('.*EnforceStaticLibBuildRequirements.*shlib')
        assert(not [x for x in self.logFilter.records if shlibRe.match(x)])

        buildOneRecipe(recipeReqInternal)
        assert("+ EnforceStaticLibBuildRequirements: Add 'asdf:devel' to buildRequires for -lasdf (%s/libasdf.a)" %libdir in self.logFilter.records)
        assert("+ EnforceStaticLibBuildRequirements: No files found matching -linternal: possible missing buildRequires" not in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['asdf:devel']" in self.logFilter.records)

        buildOneRecipe(recipeReqInternalUninstalled)
        assert("+ EnforceStaticLibBuildRequirements: Add 'asdf:devel' to buildRequires for -lasdf (%s/libasdf.a)" %libdir in self.logFilter.records)
        # testing buildDirContains(libName)
        assert("+ EnforceStaticLibBuildRequirements: No files found matching -linternal: possible missing buildRequires" not in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['asdf:devel']" in self.logFilter.records)
        assert(not [x for x in self.logFilter.records if x.startswith('+ EnforceStaticLibBuildRequirements: No trove found matching any of files')])

        buildOneRecipe(recipeReqMissing)
        foundRe = re.compile('.*EnforceStaticLibBuildRequirements.*asdf.*')
        assert(not [x for x in self.logFilter.records if foundRe.match(x)])
        assert('+ EnforceStaticLibBuildRequirements: No files found matching -lnonesuch: possible missing buildRequires' in self.logFilter.records)
        # only mention this once...
        assert(len([x for x in self.logFilter.records if x == '+ EnforceStaticLibBuildRequirements: No files found matching -lnonesuch: possible missing buildRequires']) == 1)

        # Now test the error paths that require modifying the workdir
        self.updatePkg(self.workDir, 'asdup', '0')
        buildOneRecipe(recipeReqTerminal)
        assert("warning: EnforceStaticLibBuildRequirements: Multiple troves match files %s/libasdf.a %s/libasdf.a for -lasdf: choose one of the following entries for buildRequires: 'asdf:devel', 'asdup:devel'" %(elibdir, libdir) in self.logFilter.records)
        assert("+ EnforceStaticLibBuildRequirements: Add 'asdf:devel' to buildRequires for -lasdf (%s/libasdf.a)" %libdir not in self.logFilter.records)
        assert("warning: EnforceStaticLibBuildRequirements: add to buildRequires: ['asdf:devel']" not in self.logFilter.records)

        unmanagedLib = '%s/%s/libfoo.a' %(self.workDir, libdir)
        util.mkdirChain(os.path.dirname(unmanagedLib))
        file(unmanagedLib, 'a')
        buildOneRecipe(recipeReqUnmanaged)
        assert("+ EnforceStaticLibBuildRequirements: No trove found matching any of files %s/libfoo.a for -lfoo: possible missing buildRequires" %libdir in self.logFilter.records)
        os.unlink(unmanagedLib)



class NonLSBPathsTest(rephelp.RepositoryHelper):
    def testNonLSBPaths(self):
        recipestr = r"""
class Test(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create('/usr/usr/oh-no')
        r.Create('/usr/local/tsktsk')
"""
        self.logFilter.add()
        self.assertRaises(policy.PolicyError, self.buildRecipe,
            recipestr, "Test")
        self.logFilter.remove()
        assert('warning: NonLSBPaths: Found path /usr/local: /usr/local is recommended by the LSB only for non-packaged files' in self.logFilter.records)
        assert('error: NonLSBPaths: Found path /usr/usr: /usr/usr is usually caused by using %(prefix)s instead of /' in self.logFilter.records)

class CrossCompileTest(rephelp.RepositoryHelper):
    def testCrossToolProvidesRequires(self):

        recipestr = r"""
class Test(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()

    def setup(r):
        if Use.cross:
            pass
        r.Create('/lib/foo')
        r.Create('/asdf/foo')
        r.Create('hello.c', contents='''#include <stdio.h>
int main(void) {return printf("Hello, world."); }
''')
        r.Run('gcc -c hello.c -o hello')
        r.Install('hello', '%(bindir)s/', mode=0755)
        r.Requires('foo:runtime(foo)', '/asdf/foo')
        r.Requires('bar:runtime(target-%(target)s)', '/asdf/foo')
"""
        thisArch = [x[0] for x in list(use.Arch.items()) if x[1]]
        self.assertEqual(len(thisArch), 1)
        thisArch = thisArch[0]
        archMap = dict(x86=('x86', 'x86_64', '32'), x86_64=('x86 x86_64', 'x86', '64'))
        majorArch, otherArch, bits = archMap[thisArch]
        if otherArch == 'x86':
            target = 'i386'
        else:
            target = otherArch
        flv = 'cross is: %s target: %s' % (majorArch, otherArch)
        self.overrideBuildFlavor(flv)
        (built, d) = self.buildRecipe(recipestr, "Test")

        runtime = self.findAndGetTrove('test:runtime[%s]' % flv)
        self.assertEqual(str(runtime.getFlavor()), flv)
        abi = "ELF%s(SysV %s)" % (bits, thisArch)
        kwdict = dict(abi = abi, target = target)
        self.assertEqual(str(runtime.getRequires()), """\
abi: %(abi)s
trove: bar:runtime(target-%(target)s-unknown-linux)
trove: foo:runtime(foo)
trove: test:lib(target-%(target)s-unknown-linux)""" % kwdict)
        assert(str(runtime.getProvides()) == """\
file: /usr/bin/hello
trove: test:runtime(target-%(target)s-unknown-linux)""" % kwdict)

class EnforceExclusionTest(rephelp.RepositoryHelper):
    def testUnusedExclude(self):
        recipeStr = """
class Unused(PackageRecipe):
    name = 'unused'
    version = '1.0.0'
    clearBuildReqs()

    def setup(r):
        r.MakeDirs('/foo/bar/baz')
        r.ExcludeDirectories(exceptions = '/foo/bar/baz')

        r.ExcludeDirectories(exceptions = '/missing/exclusion')
        r.ExcludeDirectories('/missing/inclusion')
        r.ExcludeDirectories(exceptions = '/missing/allowed_ex', allowUnusedFilters = True)
        r.ExcludeDirectories('/missing/allowed_inc', allowUnusedFilters = True)"""

        self.logFilter.add()
        self.buildRecipe(recipeStr, "Unused")
        self.logFilter.remove()
        self.logFilter.compare(
                ['warning: ExcludeDirectories: '
                        'Exception ^/missing/exclusion$ for '
                        'ExcludeDirectories was not used',
                 'warning: ExcludeDirectories: Inclusion '
                        '^/missing/inclusion$ for ExcludeDirectories '
                        'was not used'])

    def testConfigDrop(self):
        recipeStr = """
class ConfigDrop(PackageRecipe):
    name = 'configdrop'
    version = '1.0.0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/foo', contents = "test")
        r.Remove('/etc/foo'),
        r.Config(exceptions = '/etc/foo')"""

        # test that Config can't match a removed file
        self.logFilter.add()
        self.buildRecipe(recipeStr, "ConfigDrop")
        self.logFilter.remove()
        self.assertEqual(self.logFilter.records[0],
            'warning: Config: Exception ^/etc/foo$ for Config was not used')

class StandaloneElfABI(rephelp.RepositoryHelper):
    def testStandaloneElfABI(self):
        recipestr = r"""
class Test(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.addSource('elf-abi-standalone', dir = '/usr/lib/file')
"""

        (built, d) = self.buildRecipe(recipestr, "Test")

        # That elf file was generated by running:
        # nasm -f bin -o archive/elf-abi-standalone /tmp/elfhdr.asm
        # where /tmp/elfhdr.asm is the following file:
        """
  BITS 32

                org     0x08048000

  ehdr:                                                 ; Elf32_Ehdr
                db      0x7F, "ELF", 1, 1, 1            ;   e_ident
                db      255
                db      0
                db      0
                db      0
                db      0
                db      0
                db      0
                db      0
                db      0
                dw      2                               ;   e_type
                dw      3                               ;   e_machine
                dd      1                               ;   e_version
                dd      _start                          ;   e_entry
                dd      phdr - $$                       ;   e_phoff
                dd      0                               ;   e_shoff
                dd      0                               ;   e_flags
                dw      ehdrsize                        ;   e_ehsize
                dw      phdrsize                        ;   e_phentsize
                dw      1                               ;   e_phnum
                dw      0                               ;   e_shentsize
                dw      0                               ;   e_shnum
                dw      0                               ;   e_shstrndx

  ehdrsize      equ     $ - ehdr

  phdr:                                                 ; Elf32_Phdr
                dd      1                               ;   p_type
                dd      0                               ;   p_offset
                dd      $$                              ;   p_vaddr
                dd      $$                              ;   p_paddr
                dd      filesize                        ;   p_filesz
                dd      filesize                        ;   p_memsz
                dd      5                               ;   p_flags
                dd      0x1000                          ;   p_align

  phdrsize      equ     $ - phdr

  _start:

  filesize      equ     $ - $$
"""

class RecordMoveTest(rephelp.RepositoryHelper):
    def setUp(self):
        rephelp.RepositoryHelper.setUp(self)
        self.destdir = os.path.join(self.tmpDir, '_ROOT_')
        util.mkdirChain(self.destdir)

    def tearDown(self):
        util.rmtree(self.destdir)
        rephelp.RepositoryHelper.tearDown(self)

    def touch(self, fn, contents = ''):
        if not contents and os.path.exists(fn):
            return
        util.mkdirChain(os.path.dirname(fn))
        f = open(fn, 'w')
        f.write(contents)
        f.close()

    def getRecipe(self):
        class DummyPackageRecipe(packagerecipe.PackageRecipe):
            def __init__(x):
                x.name = 'package'
                x.version = '1.0'
                packagerecipe.PackageRecipe.__init__(x, self.cfg, None, None)
                x._loadSourceActions(lambda y: True)
                x.loadPolicy()
                x.macros.destdir = self.destdir
        return DummyPackageRecipe()

    def testRecordMissing(self):
        src = os.path.join(self.destdir, 'a')
        dest = os.path.join(self.destdir, 'b')
        r = self.getRecipe()
        r.recordMove(src, dest)
        self.assertEqual(r._pathTranslations, [('/a', '/b')])

    def testRecordFile1(self):
        src = os.path.join(self.destdir, 'a')
        dest = os.path.join(self.destdir, 'b')
        self.touch(src)
        r = self.getRecipe()
        r.recordMove(src, dest)
        self.assertEqual(r._pathTranslations, [('/a', '/b')])

    def testRecordFile2(self):
        src = os.path.join(self.destdir, 'a')
        dest = os.path.join(self.destdir, 'b')
        r = self.getRecipe()
        self.touch(dest)
        r.recordMove(src, dest)
        self.assertEqual(r._pathTranslations, [('/a', '/b')])

    def testRecordExtraSep(self):
        src = os.path.sep + os.path.join(self.destdir, 'a')
        dest = os.path.sep + os.path.join(self.destdir, 'b')
        self.touch(src)
        r = self.getRecipe()
        r.recordMove(src, dest)
        self.assertEqual(r._pathTranslations, [('/a', '/b')])

    def testRecordDirSrc(self):
        # test that a directory that hasn't been moved yet gets recorded
        # recursively. be sure to account for subdirs
        src = os.path.join(self.destdir, 'srcdir')
        fn = os.path.join(src, 'subdir', 'a')
        dest = os.path.join(self.destdir, 'destdir')
        self.touch(fn)
        r = self.getRecipe()
        r.recordMove(src, dest)
        self.assertEqual(r._pathTranslations,
                [('/srcdir', '/destdir'),
                    ('/srcdir/subdir', '/destdir/subdir'),
                    ('/srcdir/subdir/a', '/destdir/subdir/a')])

    def testRecordDirDest(self):
        # test that a directory that already been moved yet gets recorded
        # recursively. be sure to account for subdirs
        src = os.path.join(self.destdir, 'srcdir')
        dest = os.path.join(self.destdir, 'destdir')
        fn = os.path.join(dest, 'subdir', 'a')
        self.touch(fn)
        r = self.getRecipe()
        r.recordMove(src, dest)
        self.assertEqual(r._pathTranslations,
                [('/srcdir', '/destdir'),
                    ('/srcdir/subdir', '/destdir/subdir'),
                    ('/srcdir/subdir/a', '/destdir/subdir/a')])

class RecipeTest(rephelp.RepositoryHelper):
    def testRecipeComponent(self):
        recipestr = """
class SuperClass(PackageRecipe):
    name = 'super'
    version = '0'
    abstractBaseClass = True
    clearBuildReqs()

    def setupAbstractBaseClass(r):
        r.Create('%(datadir)s/conary/baseclasses/super.recipe')
"""
        (built, d) = self.buildRecipe(recipestr, "SuperClass")
        self.assertEqual(built, [('super:recipe', '/localhost@rpl:linux/0-1-1', deps.parseFlavor(''))])

class TroveScriptsTest(rephelp.RepositoryHelper):
    def testTroveScripts(self):
        recipestr = """
class TroveScriptsRecipe(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create("/usr/share/foo", contents = "Contents")
        r.Create("/usr/share/bar", contents = "Contents-bar")
        r.PackageSpec("testpkgspec", "/usr/share/bar")
        r.ScriptPreErase('test', 'test:data', 'test:foo', 'testpkgspec', contents = "preerase")
        r.ScriptPostErase('test', 'test:data', 'test:foo', 'testpkgspec', contents = "posterase")
        r.ScriptPreInstall('test', 'test:data', 'test:foo', 'testpkgspec', contents = "preinstall")
        r.ScriptPostInstall('test', 'test:data', 'test:foo', 'testpkgspec', contents = "postinstall")
        r.ScriptPreUpdate('test', 'test:data', 'test:foo', 'testpkgspec', contents = "preupdate")
        r.ScriptPostUpdate('test', 'test:data', 'test:foo', 'testpkgspec', contents = "postupdate")
        r.ScriptPreRollback('test', 'test:data', 'test:foo', 'testpkgspec', contents = "prerollback")
        r.ScriptPostRollback('test', 'test:data', 'test:foo', 'testpkgspec', contents = "postrollback")
"""
        retTroves = self.build(recipestr, "TroveScriptsRecipe",
            returnTrove=['test', 'testpkgspec', 'test:data',
                           'testpkgspec:data'])
        scriptTypes = [ y[2] for (x, y) in
                        list(trove.TroveScripts.streamDict.items()) ]
        for trv in retTroves[:3]:
            for scriptType in scriptTypes:
                scriptCont = getattr(trv.troveInfo.scripts, scriptType).script()
                self.assertEqual(scriptCont, scriptType.lower())
        for trv in retTroves[3:]:
            for scriptType in scriptTypes:
                scriptCont = getattr(trv.troveInfo.scripts, scriptType).script()
                self.assertEqual(scriptCont, '')


class ExcessBuildRequiresTest(rephelp.RepositoryHelper):
    def uniqComponent(self, *args, **kw):
        kw['filePrimer'] = self.filePrimer
        self.addComponent(*args, **kw)
        self.filePrimer += 1

    def testExcessBuildRequires(self):
        self.filePrimer = 0
        # ensure that setup:runtime is not mentioned as excessive in superclass
        # tests removeCore
        self.uniqComponent('setup:runtime')
        # make sure that arbitrary:runtime is not mentioned as excessive
        # tests removeSome
        self.uniqComponent('arbitrary:runtime')
        # test transitive closure with components
        for scope in ('', 'super-'):
            for necessity in ('', 'un'):
                troveDep = deps.parseDep(
                    'trove: %s%snecessary:implicit'%(scope, necessity))
                self.uniqComponent('%s%snecessary:implicit'%(scope, necessity),
                                  provides=troveDep)
                self.uniqComponent('%s%snecessary:explicit'%(scope, necessity),
                                  requires=troveDep)
        # test removeDupComponents
        self.uniqComponent('super-necessary:unrelated')
        # test transitive closure with packages
        troveDep = deps.parseDep('trove: implicit:runtime')
        self.uniqComponent('implicit:runtime', provides=troveDep)
        self.uniqComponent('explicit:runtime', requires=troveDep)
        # test that there is a simply unused non-superclass buildreq
        # tests _reportExcessBuildRequires
        self.uniqComponent('unused:devel')
        self.uniqComponent('duplicate:devel')

        self.updatePkg([
            'setup:runtime', 'arbitrary:runtime',
            'necessary:implicit', 'necessary:explicit',
            'unnecessary:implicit', 'unnecessary:explicit',
            'super-necessary:implicit', 'super-necessary:explicit',
            'super-unnecessary:implicit', 'super-unnecessary:explicit',
            'super-necessary:unrelated',
            'unused:devel', 'duplicate:devel',
            'implicit:runtime', 'explicit:runtime',
        ])

        superClassRecipeStr = """
class SuperRecipe(PackageRecipe):
    name = 'super'
    version = '1'
    clearBuildRequires()
    buildRequires = [
        'setup:runtime',
        'super-necessary:explicit',
        'super-unnecessary:explicit',
        'super-necessary:unrelated',
        'duplicate:devel',
        'explicit:runtime',
    ]
"""

        subClassRecipeStr = """
loadSuperClass('super')
class Sub(SuperRecipe):
    name = 'sub'
    version = '1'
    buildRequires = [
        'arbitrary:runtime',
        'necessary:explicit',
        'unnecessary:explicit',
        'unused:devel',
        'duplicate:devel',
        # Note: 'implicit:runtime' not here
    ]
    def setup(r):
        # these are the things that really get used
        r.reportExcessBuildRequires('necessary:explicit')
        r.reportExcessBuildRequires(['super-necessary:explicit'])
        r.reportExcessBuildRequires(('implicit:runtime',))
        r.Create('/opt/dummy')
"""
        subClassRecipeStrEmpty = """
loadSuperClass('super')
class SubEmpty(SuperRecipe):
    name = 'subempty'
    version = '1'
    def setup(r):
        r.Create('/opt/dummy')
"""

        self.uniqComponent('super:source',
                           [('super.recipe', superClassRecipeStr)])

        reportedRealReqs = set()
        realUA = packagepolicy.reportExcessBuildRequires.updateArgs
        self.mock(packagepolicy.reportExcessBuildRequires, 'updateArgs',
                  lambda *args:
                    mockedSaveArgSet(args[0], realUA, reportedRealReqs, *args[1:]))
        reportedExcess = set()
        self.mock(packagepolicy.reportExcessBuildRequires,
                  '_reportExcessBuildRequires',
                  lambda *args:
                    mockedSaveArgSet(args[0], None, reportedExcess, *args[1:]))
        reportedSuperExcess = set()
        self.mock(packagepolicy.reportExcessBuildRequires,
                  '_reportExcessSuperclassBuildRequires',
                  lambda *args:
                    mockedSaveArgSet(args[0], None, reportedSuperExcess, *args[1:]))
        repos = self.openRepository()
        self.buildRecipe(subClassRecipeStr, "Sub", repos=repos, logBuild=True)
        self.assertEqual(reportedRealReqs,
                          set(['super-necessary:explicit',
                               'necessary:explicit',
                               'implicit:runtime']))
        self.assertEqual(reportedExcess,
                          set(['unnecessary:explicit',
                               'duplicate:devel',
                               'unused:devel']))

        # Note that 'implicit:runtime' is not in the next set
        self.assertEqual(reportedSuperExcess,
                          set(['super-unnecessary:explicit',
                               'duplicate:devel',
                               'explicit:runtime',]))

        reportedExcess.clear()
        self.buildRecipe(subClassRecipeStrEmpty, "SubEmpty", repos=repos, logBuild=True)
        # make sure superclass buildRequires are not reported as
        # subclass buildRequires
        self.assertEqual(reportedExcess, set([]))


    def _testPythonSetupRequires(self, importLine):
        recipeStr = """
class SetupBuildReq(PackageRecipe):
    name = 'setupbuildreq'
    version = '1'
    clearBuildReqs()
    buildRequires = ['python-setuptools:python', 'bogus:devel', 'present:lib']

    def setup(r):
       r.Create('setup.py', contents=chr(10).join((
            '#!python',
            '%s',
            'use_setuptools()', '')))
       r.PythonSetup()
       # ensure one control buildReq is bogus and one is valid
       r.reportExcessBuildRequires('present:lib')
       r.Create('/opt/dontfail')
""" % importLine
        # set up build env
        provides = deps.ThawDependencySet('4#python-setuptools::python')
        trv = self.addComponent('python-setuptools:python', provides = provides)
        self.updatePkg(self.workDir, trv.getName(), trv.getVersion())
        trv = self.addComponent('bogus:devel')
        self.updatePkg(self.workDir, trv.getName(), trv.getVersion())
        trv = self.addComponent('present:lib')
        self.updatePkg(self.workDir, trv.getName(), trv.getVersion())

        self.savedArgs = set()
        realUpdateArgs = packagepolicy.reportExcessBuildRequires.updateArgs
        def dummyUpdateArgs(policy, arg):
            if isinstance(arg, set):
                self.savedArgs.update(arg)
            else:
                self.savedArgs.add(arg)
            return realUpdateArgs(policy, arg)
        self.mock(util, 'execute', lambda *args, **kwargs: None)
        self.mock(packagepolicy.reportExcessBuildRequires, 'updateArgs',
                dummyUpdateArgs)
        built, d = self.buildRecipe(recipeStr, 'SetupBuildReq', logBuild = True,
                logLevel = log.INFO)

        nvf = [x for x in built if ':debuginfo' in x[0]][0]
        nvf = nvf[0], versions.VersionFromString(nvf[1]), nvf[2]
        client = self.getConaryClient()
        fileDict = client.getFilesFromTrove(*nvf)
        bz = fileDict['/usr/src/debug/buildlogs/setupbuildreq-1-log.bz2'].read()
        data = bz2.BZ2Decompressor().decompress(bz)
        lines = [x for x in data.splitlines() \
                if 'Possible excessive buildRequires' in x]
        self.assertFalse(not lines, "Expected bogus:devel to be excessive")
        line = lines[0]
        self.assertFalse('python-setuptools:python' not in self.savedArgs)

        self.assertEqual(line, \
                "info: Possible excessive buildRequires: ['bogus:devel']")

    def testEzSetupRequires(self):
        self._testPythonSetupRequires("from ez_setup import use_setuptools")

    def testSetupRequires(self):
        self._testPythonSetupRequires("import setuptools")

class MetadataTest(rephelp.RepositoryHelper):
    def testSetDescription(self):
        recipestr = """
class TestRecipe(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.Create("/usr/share/filesub1cmp1", contents="11")
        r.Create("/usr/share/filesub1cmp2", contents="12")
        r.Create("/usr/share/filesub2cmp1", contents="21")
        r.Create("/usr/share/filesub2cmp2", contents="22")
        r.PackageSpec('subtest1', '/usr/share/filesub1.*')
        r.PackageSpec('subtest2', '/usr/share/filesub2.*')
        r.ComponentSpec('comp1', '.*cmp1')
        r.ComponentSpec('comp2', '.*cmp2')
        %(d1)s
        %(d2)s
"""
        shortDesc = "shortDesc"
        longDesc = "Oh hai, this is %(name)s. Srsly."
        language = "en_LOL.UTF-8"
        licenses = ['GPLv3', 'Apache', '%(name)s-license']
        replDict = {
            'd1' : "r.Description(shortDesc = '%s', longDesc = '%s', "
                   "language = '%s')" %
                    (shortDesc, longDesc, language),
            'd2' : "r.Licenses(%s, language='%s')" %
                    (', '.join("'%s'" % x for x in licenses), language,),
        }
        returnTroves = ['subtest1', 'subtest2',
                           'subtest1:comp1', 'subtest1:comp2',
                           'subtest2:comp1', 'subtest2:comp2',]

        r1 = recipestr % replDict
        troves = self.build(r1, "TestRecipe", returnTrove=returnTroves)
        troves = sorted(troves, key = lambda x: x.getName())

        licenses = [ x % dict(name = 'test') for x in licenses ]
        licenses.sort()

        longDesc = longDesc % dict(name = 'test')
        for i in range(2):
            mainTrv = troves[3*i]
            for j in range(2):
                comp = troves[3*i + j + 1]
                files = [ x[1] for x in comp.iterFileList() ]
                self.assertEqual(files, [ "/usr/share/filesub%scmp%s" %
                    (i + 1, j + 1)])
                metadata = comp.troveInfo.metadata
                # Default language should be present
                self.assertEqual(len(metadata.getItems()), 1)
                self.assertEqual(list(metadata.getItems().values())[0], [])
            metadata = mainTrv.troveInfo.metadata
            self.assertEqual(len(metadata.getItems()), 1)
            mi = metadata.get(language)
            self.assertEqual(mi['shortDesc'], shortDesc)
            self.assertEqual(mi['longDesc'], longDesc)
            self.assertEqual(mi['licenses'], licenses)

        # Similar deal, but only set the description on some troves
        longDesc2= "Oh hai, this is the second description, with %(name)s in it."
        licenses2 = ['MIT', 'GPL', "%(name)s"]
        licenses2.sort()
        replDict = {
            'd1' : "r.Description(shortDesc = '%s', longDesc = '%s', "
                   "language = '%s', troveNames = ['subtest1', ':comp2'], "
                    "macros = False)" % (shortDesc, longDesc2, language),
            'd2' : "r.Licenses(%s, language='%s', "
                    "troveNames = ['subtest1', ':comp2'], macros = False)" %
                    (', '.join("'%s'" % x for x in licenses2), language,),
        }
        r1 = recipestr % replDict
        troves = self.build(r1, "TestRecipe", returnTrove=returnTroves)
        troves = sorted(troves, key = lambda x: x.getName())

        for i in range(2):
            for j in range(2):
                comp = troves[3*i + j + 1]
                metadata = comp.troveInfo.metadata
                self.assertEqual(len(metadata.getItems()), 1)
                if comp.name().endswith(':comp2'):
                    mi = metadata.get(language)
                    self.assertEqual(mi['shortDesc'], shortDesc)
                    self.assertEqual(mi['longDesc'], longDesc2)
                    self.assertEqual(mi['licenses'], licenses2)
                else:
                    self.assertEqual(list(metadata.getItems().values())[0], [])
            metadata = mainTrv.troveInfo.metadata
            self.assertEqual(len(metadata.getItems()), 1)
            mi = metadata.get(language)
            self.assertEqual(mi['shortDesc'], shortDesc)
            # Both main troves have the same short desc. Even though we
            # haven't set the description in subtest2, it gets copied forward.
            if mainTrv.name() == 'subtest1':
                self.assertEqual(mi['longDesc'], longDesc2)
                self.assertEqual(mi['licenses'], licenses2)
            else:
                self.assertEqual(mi['longDesc'], longDesc)
                self.assertEqual(mi['licenses'], licenses)

    def testKeyValueMetadata(self):
        mi = trove.MetadataItem()
        mi.keyValue.update(dict(a = '1', b = '2'))
        self.addComponent("foo:runtime", version = "0.1")
        trv = self.addCollection("foo", "0.1", [ "foo:runtime" ], metadata = mi)

        repos = self.openRepository()

        # Make sure the metadata is there
        jobList = [ ( trv.getName(), (None, None),
                      (trv.getVersion(), trv.getFlavor()), True) ]
        cs = repos.createChangeSet(jobList)
        trvCs = [ x for x in cs.iterNewTroveList() if x.getName() == 'foo' ][0]
        trv = trove.Trove(trvCs)
        self.assertEqual(
            sorted(trv.troveInfo.metadata.get()['keyValue'].items()),
            [('a', '1'), ('b', '2')])

        # Now cook a version
        recipestr = """
class FooRecipe(PackageRecipe):
    name = 'foo'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.metadataSkipSet.remove('keyValue')
        r.Create("/usr/share/foo", contents="11")
        r.ResetKeyValueMetadata('a')
"""
        trv = self.build(recipestr, "FooRecipe", returnTrove='foo')
        self.assertEqual(
            sorted(trv.troveInfo.metadata.get()['keyValue'].items()),
            [('b', '2')])

        # Cook again, with no arguments to ResetKeyValueMetadata; everything
        # should be kept
        recipestr = """
class FooRecipe(PackageRecipe):
    name = 'foo'
    version = '2'
    clearBuildReqs()

    def setup(r):
        r.metadataSkipSet.remove('keyValue')
        r.Create("/usr/share/foo", contents="11")
"""
        trv = self.build(recipestr, "FooRecipe", returnTrove='foo')
        self.assertEqual(
            sorted(trv.troveInfo.metadata.get()['keyValue'].items()),
            [('b', '2')])

        # Cook again without removing keyValue from the skip set, metadata
        # should not be copied to the new version.
        recipestr = """
class FooRecipe(PackageRecipe):
    name = 'foo'
    version = '3'
    clearBuildReqs()

    def setup(r):
        r.Create("/usr/share/foo", contents="11")
"""
        trv = self.build(recipestr, "FooRecipe", returnTrove='foo')
        self.assertFalse('keyValue' in trv.troveInfo.metadata)

        # Set metadata remotely
        mi = trove.MetadataItem()
        mi.keyValue.update(dict(a = '11', b = '22'))
        nvf = trv.getNameVersionFlavor()
        repos.addMetadataItems([ (nvf, mi) ])

        trvMetaList = repos.getTroveInfo(trove._TROVEINFO_TAG_METADATA, [ nvf ])
        trvMeta = trvMetaList[0]
        self.assertEqual(sorted(trvMeta.get()['keyValue'].items()),
            [('a', '11'), ('b', '22')])

class UserGroupInfoTest(rephelp.RepositoryHelper):
    def testUserFile(self):
        recipestr1 = r"""
class TestAutoUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/userinfo/apache',
                contents = '\n'.join((
                    "PREFERRED_UID=48",
                    "HOMEDIR=/var/www",
                    "COMMENT=Apache",
                    "SHELL=/sbin/nologin")))
"""
        built, d = self.buildRecipe(recipestr1, "TestAutoUser")
        self.openRepository()
        self.assertEqual(built[0][0], 'info-apache:user')
        for p in built:
            self.updatePkg(self.workDir, p[0], p[1])
        self.assertFalse(not os.path.exists(os.path.join(self.workDir,
                                                    'etc', 'passwd')))

    def testGroupFile(self):
        recipestr1 = r"""
class TestAutoGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/groupinfo/wheel', contents = "PREFERRED_GID=10")
"""
        built, d = self.buildRecipe(recipestr1, "TestAutoGroup")
        self.openRepository()
        self.assertEqual(built[0][0], 'info-wheel:group')
        for p in built:
            self.updatePkg(self.workDir, p[0], p[1])
        self.assertFalse(not os.path.exists(os.path.join(self.workDir,
                                                    'etc', 'group')))

    def testInfoPackageIsolation(self):
        recipestr1 = r"""
class TestOverloadedGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/groupinfo/wheel', contents = "PREFERRED_GID=10")
        r.Create('/not/legal/info1', package = 'info-wheel:group')
        r.Create('/not/legal/info2', package = 'info-wheel:group')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestOverloadedGroup")
        self.assertEqual(str(err),
                "Package Policy errors found:\nProcessGroupInfoPackage: "
                "The following files are not allowed in 'info-wheel:group': "
                "'/not/legal/info1', '/not/legal/info2'")

    def testInfoPackageIsolation2(self):
        recipestr1 = r"""
class TestOverloadedGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/userinfo/apache',
                contents = '\n'.join((
                    "PREFERRED_UID=48",
                    "HOMEDIR=/var/www",
                    "COMMENT=Apache",
                    "SHELL=/sbin/nologin")))
        r.Create('/not/legal/info', package = 'info-apache:user')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestOverloadedGroup")
        self.assertEqual(str(err),
                "Package Policy errors found:\nProcessUserInfoPackage: "
                "The following files are not allowed in 'info-apache:user': "
                "'/not/legal/info'")

    def testUserInfoPackageBadName(self):
        recipestr1 = r"""
class TestBadUserName(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/userinfo/apache',
                contents = '\n'.join((
                    "PREFERRED_UID=48",
                    "HOMEDIR=/var/www",
                    "COMMENT=Apache",
                    "SHELL=/sbin/nologin")),
                package = "not-info:config")
"""
        built, d = self.buildRecipe(recipestr1, "TestBadUserName")
        self.assertEqual(built[0][0], 'info-apache:user')

    def testGroupInfoPackageBadName(self):
        recipestr1 = r"""
class TestBadGroupName(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/groupinfo/wheel', contents = "PREFERRED_GID=5",
                package = "not-info:config")
"""
        built, d = self.buildRecipe(recipestr1, "TestBadGroupName")
        self.assertEqual(built[0][0], 'info-wheel:group')

    def testPackageSupplementalGroup(self):
        recipestr1 = r"""
class TestSupplementalGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('%(bindir)s/foo', mode = 0755)
        r.SupplementalGroup('user', 'group', 5)
"""
        built, d = self.buildRecipe(recipestr1, "TestSupplementalGroup")
        self.assertEqual(sorted([x[0] for x in built]),
                ['info-group:group', 'test:runtime'])
        client = self.getConaryClient()
        nvf = [x for x in built if x[0] == 'info-group:group'][0]
        nvf = nvf[0], versions.VersionFromString(nvf[1]), nvf[2]
        fn = '/etc/conary/groupinfo/group'
        fileDict = client.getFilesFromTrove(nvf[0], nvf[1], nvf[2], [fn])
        res = fileDict[fn].read()
        ref = '\n'.join(('PREFERRED_GID=5', 'USER=user', ''))

        self.assertEqual(res, ref)

        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.provides(),
                deps.ThawDependencySet('4#info-group::group|8#group'))

        self.assertEqual(trv.requires(), deps.ThawDependencySet('7#user'))

    def testPackageGroup(self):
        recipestr1 = r"""
class TestGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('%(bindir)s/foo', mode = 0755)
        r.Group('group', 5)
"""
        built, d = self.buildRecipe(recipestr1, "TestGroup")
        self.assertEqual(sorted([x[0] for x in built]),
                ['info-group:group', 'test:runtime'])
        client = self.getConaryClient()
        nvf = [x for x in built if x[0] == 'info-group:group'][0]
        nvf = nvf[0], versions.VersionFromString(nvf[1]), nvf[2]
        fn = '/etc/conary/groupinfo/group'
        fileDict = client.getFilesFromTrove(nvf[0], nvf[1], nvf[2], [fn])
        res = fileDict[fn].read()
        ref = 'PREFERRED_GID=5\n'

        self.assertEqual(res, ref)

        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.provides(),
                deps.ThawDependencySet('4#info-group::group|8#group'))

        self.assertEqual(trv.requires(), deps.ThawDependencySet(''))

    def testPackageUser(self):
        recipestr1 = r"""
class TestUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('%(bindir)s/foo', mode = 0755)
        r.User(name = 'user', preferred_uid = 96, group = 'group',
                groupid = 5, homedir = '/home/foo', comment = 'random comment')
"""
        built, d = self.buildRecipe(recipestr1, "TestUser")
        self.assertEqual(sorted([x[0] for x in built]),
                ['info-group:group', 'info-user:user', 'test:runtime'])
        client = self.getConaryClient()
        nvf = [x for x in built if x[0] == 'info-user:user'][0]
        nvf = nvf[0], versions.VersionFromString(nvf[1]), nvf[2]
        fn = '/etc/conary/userinfo/user'
        fileDict = client.getFilesFromTrove(nvf[0], nvf[1], nvf[2], [fn])
        res = fileDict[fn].read()
        ref = '\n'.join(('PREFERRED_UID=96', 'GROUP=group', 'GROUPID=5',
                'HOMEDIR=/home/foo', 'COMMENT=random comment',
                'SHELL=/sbin/nologin', ''))

        self.assertEqual(res, ref)

        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.provides(),
                deps.ThawDependencySet('4#info-user::user|7#user'))
        self.assertEqual(trv.requires,
                deps.ThawDependencySet('8#group'))

        specs = [ x for x in built if x[0] == 'info-group:group' ]
        self.assertTrue(specs)
        nvf = repos.findTrove(None, specs[0])[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.provides,
            deps.ThawDependencySet('4#info-group::group|8#group'))

        self.assertEqual(trv.requires(), deps.ThawDependencySet(''))

    def testBadUserRequires(self):
        recipestr1 = r"""
class TestUserRequires(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.User(name = 'splat', preferred_uid = 96, group = 'group',
                groupid = 42, homedir = '/home/foo', comment = 'random comment')
        r.Requires('foo:runtime', '.*')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestUserRequires")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessGroupInfoPackage: Illegal requirement on "
                "'info-group:group': 'trove: foo:runtime'\n"
                "ProcessUserInfoPackage: Illegal requirement on "
                "'info-splat:user': 'trove: foo:runtime'")

    def testBadGroupRequires(self):
        recipestr1 = r"""
class TestGroupRequires(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Group(name = 'bar', preferred_gid = 1)
        r.Requires('foo:runtime', '.*')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestGroupRequires")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessGroupInfoPackage: Illegal requirement on "
                "'info-bar:group': 'trove: foo:runtime'")

    def testBadUserProvides(self):
        recipestr1 = r"""
class TestUserProvides(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.User('crunchy', 41, groupid = 42, comment = 'mixed order',
                homedir = '/home/foo')
        r.Provides('abi: (crunchy)', '.*')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestUserProvides")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessGroupInfoPackage: Illegal provision for "
                "'info-crunchy:group': 'abi: (crunchy)'\n"
                "ProcessUserInfoPackage: Illegal provision for "
                "'info-crunchy:user': 'abi: (crunchy)'")

    def testBadGroupProvides(self):
        recipestr1 = r"""
class TestGroupProvides(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Group(name = 'splat', preferred_gid = 1)
        r.Provides('abi: (splat)', '.*')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestGroupProvides")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessGroupInfoPackage: Illegal provision for "
                "'info-splat:group': 'abi: (splat)'")

    def testAmbiguousDefUser(self):
        recipestr1 = r"""
class TestGroupProvides(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.User('crunch', name = 'splat', groupid = 1)
"""
        err = self.assertRaises(cook.CookError, self.buildRecipe,
                recipestr1, "TestGroupProvides")
        msg = str(err)
        self.assertEqual(msg[msg.index('UserGroupError'):],
                "UserGroupError: ambiguous defintion of 'name' "
                "positional arg: crunch and keyword arg: splat")

    def testAmbiguousDefGroup(self):
        recipestr1 = r"""
class TestGroupProvides(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Group('crunch', name = 'splat', preferred_gid = 1)
"""
        err = self.assertRaises(cook.CookError, self.buildRecipe,
                recipestr1, "TestGroupProvides")
        msg = str(err)
        self.assertEqual(msg[msg.index('UserGroupError'):],
                "UserGroupError: ambiguous defintion of 'name' "
                "positional arg: crunch and keyword arg: splat")

    def testAmbiguousDefSupGroup(self):
        recipestr1 = r"""
class TestGroupProvides(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.SupplementalGroup('crunch', user = 'conflict',
                name = 'splat', preferred_gid = 1)
"""
        err = self.assertRaises(cook.CookError, self.buildRecipe,
                recipestr1, "TestGroupProvides")
        msg = str(err)
        self.assertEqual(msg[msg.index('UserGroupError'):],
                "UserGroupError: ambiguous defintion of 'user' positional arg: "
                "crunch and keyword arg: conflict")

    def testSupplementatlGroupMulti(self):
        recipestr1 = r"""
class TestUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.User(name = 'stuff', preferred_uid = 96, group = 'group',
                provideGroup = False,
                groupid = 5, homedir = '/opt/foo',
                supplemental = ['grp1', 'grp2', 'grp3'])
"""
        built, d = self.buildRecipe(recipestr1, "TestUser")
        self.assertEqual([x[0] for x in built], ['info-stuff:user'])
        client = self.getConaryClient()
        nvf = [x for x in built if x[0] == 'info-stuff:user'][0]
        nvf = nvf[0], versions.VersionFromString(nvf[1]), nvf[2]
        fn = '/etc/conary/userinfo/stuff'
        fileDict = client.getFilesFromTrove(nvf[0], nvf[1], nvf[2], [fn])
        res = fileDict[fn].read()
        ref = '\n'.join(('PREFERRED_UID=96', 'GROUP=group', 'GROUPID=5',
                'HOMEDIR=/opt/foo', 'SHELL=/sbin/nologin',
                'SUPPLEMENTAL=grp1,grp2,grp3', ''))

        self.assertEqual(res, ref)

        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.provides(),
                deps.ThawDependencySet('4#info-stuff::user|7#stuff'))

        self.assertEqual(trv.requires(),
                deps.ThawDependencySet('8#group|8#grp1|8#grp2|8#grp3'))

    def testUserInfoFlavor(self):
        recipestr1 = r"""
class TestUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.User(name = 'stuff', preferred_uid = 96, group = 'group',
                provideGroup = False,
                groupid = 5, homedir = '/opt/foo')
        r.addSource('java-libjava.so', dest = '/opt/splat')
"""
        built, d = self.buildRecipe(recipestr1, "TestUser")
        nvf = [x for x in built if x[0] == 'info-stuff:user'][0]
        nvf = nvf[0], versions.VersionFromString(nvf[1]), nvf[2]

        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        flv = deps.parseFlavor('is: x86')
        self.assertEqual(trv.flavor(), flv)
        for nvf in built:
            self.assertEqual(nvf[2], flv)

    def testGroupInfoFlavor(self):
        recipestr1 = r"""
class TestGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Group('foo', 44)
        r.addSource('java-libjava.so', dest = '/opt/splat')
"""
        built, d = self.buildRecipe(recipestr1, "TestGroup")
        nvf = [x for x in built if x[0] == 'info-foo:group'][0]
        nvf = nvf[0], versions.VersionFromString(nvf[1]), nvf[2]

        repos = self.openRepository()
        trv = repos.getTrove(*nvf)
        flv = deps.parseFlavor('is: x86')
        self.assertEqual(trv.flavor(), flv)
        for nvf in built:
            self.assertEqual(nvf[2], flv)

    def testUserInfoTags(self):
        recipestr1 = r"""
class TestUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.User(name = 'stuff', preferred_uid = 96, group = 'group',
                provideGroup = False,
                groupid = 5, homedir = '/opt/foo')
        r.TagSpec('bad-tag', '.*')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestUser")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessUserInfoPackage: TagSpec 'bad-tag' "
                "is not allowed for info-stuff:user")

    def testGroupInfoTags(self):
        recipestr1 = r"""
class TestGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Group('one', 2)
        r.TagSpec('bad-tag', '.*')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestGroup")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessGroupInfoPackage: TagSpec 'bad-tag' "
                "is not allowed for info-one:group")

    def testBadUserInfoContents(self):
        recipestr1 = r"""
class TestAutoUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/userinfo/apache',
                contents = '\n'.join((
                    "PREFERRED_UID=48",
                    "HOMEDIR=/var/www",
                    "COMMENT=Apache",
                    "SHELL=/sbin/nologin",
                    "UNKNOWN=broken")))
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestAutoUser")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessUserInfoPackage: UNKNOWN is not is not a valid "
                "value for info-apache:user")

    def testBadGroupInfoContents(self):
        recipestr1 = r"""
class TestAutoGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/groupinfo/broken',
                contents = '\n'.join((
                    "PREFERRED_UID=48",
                    "HOMEDIR=/var/www",
                    "UNKNOWN=broken")))
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestAutoGroup")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessGroupInfoPackage: PREFERRED_UID is not is not a "
                "valid value for info-broken:group\n"
                "ProcessGroupInfoPackage: HOMEDIR is not is not a valid "
                "value for info-broken:group\n"
                "ProcessGroupInfoPackage: UNKNOWN is not is not a valid "
                "value for info-broken:group")

    def testBadUserInfoContents2(self):
        recipestr1 = r"""
class TestAutoUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/userinfo/apache', contents = "PREFERRED_UID")
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestAutoUser")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessUserInfoPackage: Unable to parse info file "
                "for 'info-apache:user'")

    def testBadGroupInfoContents2(self):
        recipestr1 = r"""
class TestAutoGroup(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.Create('/etc/conary/groupinfo/broken', contents = "trash")
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipestr1, "TestAutoGroup")
        self.assertEqual(str(err),
                "Package Policy errors found:\n"
                "ProcessGroupInfoPackage: Unable to parse info file "
                "for 'info-broken:group'")

    def testMultipleUsers(self):
        recipestr1 = r"""
class TestMultiUser(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.User('foo', 1)
        r.User('bar', 2)
"""
        built, d = self.buildRecipe(recipestr1, "TestMultiUser")
        self.assertEqual(sorted([x[0] for x in built]),
                ['info-bar:group', 'info-bar:user', 'info-foo:group',
                 'info-foo:user'])

    def testInfoExceptions(self):
        for parent in (packagepolicy.ProcessUserInfoPackage,
                packagepolicy.ProcessGroupInfoPackage):
            class DummyPolicy(parent):
                def __init__(x):
                    pass
                def error(x, msg):
                    self.assertEqual(msg,
                            "DummyPolicy does not honor exceptions")
            dummyPol = DummyPolicy()
            dummyPol.exceptions = 'test'
            dummyPol.inclusions = 'test'
            dummyPol.preProcess()

    def testUserExplicitFileFlags(self):
        recipeStr = """
class ConfigUser(PackageRecipe):
    name = 'test'
    version = '1'
    clearBuildReqs()

    def setup(r):
        r.User('bob', 1000)
        r.Config('%(userinfodir)s/bob')
        r.InitialContents('%(userinfodir)s/bob')
        #r.Transient(exceptions = '%(userinfodir)s/bob')
"""
        built, d = self.buildRecipe(recipeStr, 'ConfigUser')
        repos = self.openRepository()
        nvf = built[0][0], versions.VersionFromString(built[0][1]), built[0][2]
        trv = repos.getTrove(*nvf)
        pathId, path, fileId, ver = [x for x in trv.iterFileList()][0]
        repos.getFileVersion(pathId, fileId, ver)
        fileObj = repos.getFileVersion(pathId, fileId, ver)
        self.assertEqual(fileObj.flags(), files._FILE_FLAG_TRANSIENT)

    def testAllInfoTypes(self):
        recipeStr = """
class InfoUser(PackageRecipe):
    name = 'users'
    version = '1.0.0'
    clearBuildReqs()

    def setup(r):
        r.User('user', 96, 'group', 5, '/home/foo', 'random comment', supplemental = ['foo', 'frobinate'])
        r.Group('random', 44)
        r.SupplementalGroup('rocky', 'squirrel', 500)
        r.User('rocky', 2000, provideGroup = False)
        r.Group('rocky', 502)
"""
        built, d = self.buildRecipe(recipeStr, 'InfoUser')
        self.assertEqual(sorted([x[0] for x in built]),
                ['info-group:group', 'info-random:group', 'info-rocky:group',
                    'info-rocky:user', 'info-squirrel:group', 'info-user:user'])

    def testBadUserInfoFiletype(self):
        recipeStr = """
class InfoUser(PackageRecipe):
    name = 'users'
    version = '1.0.0'
    clearBuildReqs()

    def setup(r):
        r.Create('%(userinfodir)s/foo/bar')
"""
        err = self.assertRaises(policy.PolicyError, self.buildRecipe,
                recipeStr, 'InfoUser')
        self.assertEqual(str(err), "Package Policy errors found:\n"
                "ProcessUserInfoPackage: Only regular files may appear in "
                "'info-foo:user'")

class PHPRequiresTest(rephelp.RepositoryHelper):
    def testMissingPHPRequires(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()

    def setup(r):
        r.Create('/var/www/splat.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe', logBuild = True)
        nvf = [x for x in built if x[0] == 'php-requires:debuginfo'][0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        pathDict = client.getFilesFromTrove(*nvf)
        bzip = bz2.BZ2Decompressor()
        buildLog = bzip.decompress(pathDict[ \
                '/usr/src/debug/buildlogs/php-requires-1-log.bz2'].read())
        msg = "warning: Requires: '/var/www/splat.php' requires PHP, " \
                "which is not provided by any troves. Please add a trove " \
                "that provides the PHP interpreter to your buildRequires."
        self.assertFalse(msg not in buildLog,
                'Expected "%s" to be in buildLog' % msg)
        recipeStr += "        r.Requires(exceptions = '.*')\n"
        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe', logBuild = True)
        nvf = [x for x in built if x[0] == 'php-requires:debuginfo'][0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        pathDict = client.getFilesFromTrove(*nvf)
        bzip = bz2.BZ2Decompressor()
        buildLog = bzip.decompress(pathDict[ \
                '/usr/src/debug/buildlogs/php-requires-1-log.bz2'].read())
        self.assertFalse(msg in buildLog,
                'Expected "%s" to be omitted from buildLog' % msg)

    def testLocalPHPRequires(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()

    def setup(r):
        r.Create('/var/www/splat.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        self.addComponent('php:runtime', fileContents = {'/usr/bin/php': ''})
        self.updatePkg('php:runtime')

        # add a possibly conflicting trove to the repo to prove we can
        # definitely find the right one
        self.addComponent('php5:devel', fileContents = {'/usr/bin/php': ''})

        # test a system with no PATH. we'll rely on the default fallback paths
        PATH = os.getenv('PATH')
        try:
            del os.environ['PATH']
            (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        finally:
            os.environ['PATH'] = PATH
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet('4#php::runtime'))
        recipeStr += "        r.Requires(exceptions = '.*')\n"
        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet(''))

    def testBuildReqPHPRequires(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()
    buildRequires = ['php5:lib']

    def setup(r):
        r.Create('/var/www/splat.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        # add a trove that would satisfy the req to the repo
        self.addComponent('php:runtime', fileContents = {'/usr/bin/php': ''})

        # add another trove that would satisfy the req to the repo
        # this one's in the buildReqs so should win
        self.addComponent('php5:devel', fileContents = {'/usr/bin/php': ''})
        self.addComponent('php5:lib', fileContents = {'/usr/share/doc/php': ''})
        self.addCollection('php5', strongList = ('php5:devel', 'php5:lib'))

        # add the buildReq component to the system
        self.updatePkg('php5:lib')

        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet('4#php5::devel'))
        recipeStr += "        r.Requires(exceptions = '.*')\n"
        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet(''))

    def testBuildReqPackageMissing(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()
    buildRequires = ['missing:runtime', 'php5:lib']

    def __getattribute__(self, name):
        # buildReqs are aggregated with superclasses as a set. this ensures
        # they have the deterministic order we want to test
        if name == 'buildRequires':
            return ['missing:runtime', 'php5:lib']
        return PackageRecipe.__getattribute__(self, name)

    def setup(r):
        r.Create('/var/www/splat.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        self.addComponent('missing:runtime')
        self.updatePkg('missing:runtime')
        # add a trove that would satisfy the req to the repo
        self.addComponent('php:runtime', fileContents = {'/usr/bin/php': ''})

        # add another trove that would satisfy the req to the repo
        # this one's in the buildReqs so should win
        self.addComponent('php5:devel', fileContents = {'/usr/bin/php': ''})
        self.addComponent('php5:lib', fileContents = {'/usr/share/doc/php': ''})
        self.addCollection('php5', strongList = ('php5:devel', 'php5:lib'))

        # add the buildReq component to the system
        self.updatePkg('php5:lib')

        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet('4#php5::devel'))

    def testOnlyPHP5Binary(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()

    def setup(r):
        r.Create('/var/www/splat.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        self.addComponent('php5:runtime', fileContents = {'/usr/bin/php5': ''})
        self.addCollection('php5', strongList = ('php5:runtime',))

        # add the buildReq component to the system
        self.updatePkg('php5:runtime')

        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet('4#php5::runtime'))

    def testRepoPHPRequires(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()

    def setup(r):
        r.Create('/var/www/splat.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        self.addComponent('php:runtime', fileContents = {'/usr/bin/php': ''})

        installLabelPath = self.cfg.installLabelPath[:]
        try:
            self.cfg.installLabelPath.append(versions.Label('not@there:1'))
            (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        finally:
            self.cfg.installLabelPath = installLabelPath
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet('4#php::runtime'))
        recipeStr += "        r.Requires(exceptions = '.*')\n"
        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet(''))


    def testMultiRepoPHPRequires(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()

    def setup(r):
        r.Create('/var/www/splat.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
        r.Create('/var/www/splat2.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        self.addComponent('php:runtime', fileContents = {'/usr/bin/php': ''})
        self.addComponent('php5:devel', fileContents = {'/usr/bin/php': ''})

        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe', logBuild = True)
        nvf = [x for x in built if x[0] == 'php-requires:debuginfo'][0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        pathDict = client.getFilesFromTrove(*nvf)
        bzip = bz2.BZ2Decompressor()
        buildLog = bzip.decompress(pathDict[ \
                '/usr/src/debug/buildlogs/php-requires-1-log.bz2'].read())
        msg = "warning: Requires: '/var/www/splat.php' requires PHP, " \
                "which is provided by multiple troves. Add one of the " \
                "following troves to the recipe's buildRequires to satisfy " \
                "this dependency: ('php:runtime', 'php5:devel')"
        self.assertFalse(msg not in buildLog,
                'Expected "%s" to be in buildLog' % msg)

        # Make sure message is only presented once, thus implying that the
        # repository is only checked once.
        msg2 = "warning: Requires: '/var/www/splat2.php' requires PHP, " \
                "which is provided by multiple troves. Add one of the " \
                "following troves to the recipe's buildRequires to satisfy " \
                "this dependency: ('php:runtime', 'php5:devel')"
        self.assertFalse(buildLog.count(msg2) != 0,
            'Warning should only occure once in build log: %s' % msg)

        recipeStr += "        r.Requires(exceptions = '.*')\n"
        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe', logBuild = True)
        nvf = [x for x in built if x[0] == 'php-requires:debuginfo'][0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        pathDict = client.getFilesFromTrove(*nvf)
        bzip = bz2.BZ2Decompressor()
        buildLog = bzip.decompress(pathDict[ \
                '/usr/src/debug/buildlogs/php-requires-1-log.bz2'].read())
        self.assertFalse(msg in buildLog,
                'Expected "%s" to be omitted from buildLog' % msg)

    def testNonPHPRequires(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()

    def setup(r):
        r.Create('/var/www/splat.php', contents = 5000 * 'x')
"""
        self.addComponent('php:runtime', fileContents = {'/usr/bin/php': ''})
        self.updatePkg('php:runtime')

        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet(''))

    def testPhpCaching(self):
        recipeStr = """
class PHPRequiresRecipe(PackageRecipe):
    name = 'php-requires'
    version = '1'

    clearBuildRequires()

    def setup(r):
        r.Create('/var/www/foo.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
        r.Create('/var/www/bar.php', contents = '<html><body><?php echo "worthless PHP program"?></body></html>')
"""
        self.addComponent('php:runtime', fileContents = {'/usr/bin/php': ''})
        self.updatePkg('php:runtime')

        pathIsOwned = database.Database.pathIsOwned
        self.phpPathCount = 0
        def mockedPathIsOwned(x, path):
            if path == '/usr/bin/php':
                self.phpPathCount += 1
            return pathIsOwned(x, path)
        self.mock(database.Database, 'pathIsOwned', mockedPathIsOwned)

        (built, d) = self.buildRecipe(recipeStr, 'PHPRequiresRecipe')
        nvf = built[0]
        client = self.getConaryClient()
        repos = client.getRepos()
        nvf = repos.findTrove(None, nvf)[0]
        trv = repos.getTrove(*nvf)
        self.assertEqual(trv.getRequires(),
                deps.ThawDependencySet('4#php::runtime'))
        self.assertEqual(self.phpPathCount, 1)


class NormalizePythonInterpreterVersionTest(rephelp.RepositoryHelper):
    def testNormalizePythonInterpreterVersion(self):
        recipestr = r'''
class TestNPIV(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(bindir)s/foo', mode=0755, contents='\n'.join((
            "#!/usr/bin/python",
            "'docstring'",
        )))
        r.Create('%(datadir)s/bar', mode=0644, contents='\n'.join((
            "#!/usr/bin/python",
            "'docstring'",
        )))
        r.NormalizePythonInterpreterVersion(versionMap=(
            ('%(bindir)s/python', '%(bindir)s/python%(pyver)s'),
        ))
'''
        self.reset()
        (built, d) = self.buildRecipe(recipestr, "TestNPIV",
            macros = dict(pyver = pythonVer))

        for p in built:
            self.updatePkg(self.workDir, p[0], p[1], depCheck=False)
        for f in ('/usr/bin/foo', '/usr/share/bar'):
            header = file(self.workDir+f).readlines()[0].strip()
            self.assertTrue(('#!/usr/bin/python%s' % pythonVer) in header)


class ResolveFileDependenciesTest(rephelp.RepositoryHelper):
    recipestr1 = """
class localTrove(PackageRecipe):
    name = 'localTrove'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.addSource('smbumount')
        self.Install('smbumount', '%(bindir)s/smbunmount', mode = 0755)
        self.Create('/usr/share/existInBoth', contents='file in localTrove', package=':runtime')
        self.Create('/usr/share/dontResolve1', contents='file in localTrove', package=':runtime')
"""
    recipestr2 = """
class repoTrove(PackageRecipe):
    name = 'repoTrove'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.addSource('monodis')
        self.Install('monodis', '%(bindir)s/monodis', mode = 0755)
        self.Create('/usr/share/existInBoth', contents='file in repoTrove', package=':runtime')
        self.Create('/usr/share/existOnlyInRepo', contents='file in repoTrove', package=':runtime')
        self.Create('/usr/share/dontResolve2', contents='file in repoTrove', package=':runtime')
"""
    recipestr3 = """
class testTrove(PackageRecipe):
    name = 'testTrove'
    version = '0'
    clearBuildReqs()

    def setup(self):
        self.addSource('tmpwatch')
        self.Install('tmpwatch', '%(bindir)s/tmpwatch', mode = 0755)
        self.Requires('file: %(bindir)s/monodis', '%(bindir)s/tmpwatch')
        self.Requires('file: %(bindir)s/smbunmount', '%(bindir)s/tmpwatch')
        self.Requires('file: /usr/share/existInBoth', '%(bindir)s/tmpwatch')
        self.Requires('file: /usr/share/existOnlyInRepo', '%(bindir)s/tmpwatch')
        self.Requires('file: /usr/share/dontResolve1', '%(bindir)s/tmpwatch')
        self.Requires('file: /usr/share/dontResolve2', '%(bindir)s/tmpwatch')
        self.ResolveFileDependencies(exceptions='/usr/share/dont.*')
"""

    def testResolveFileDependencies1(self):
        # test the requires that are provided
        # in the repo or local db are not replaced
        repos = self.openRepository()

        built1, d1 = self.buildRecipe(self.recipestr1, "localTrove")
        nvf1 = built1[0]
        nvf1 = nvf1[0], versions.VersionFromString(nvf1[1]), nvf1[2]

        rc, strOut = self.captureOutput(self.updatePkg, self.rootDir,
                                     [nvf1[0]], depCheck=False)
        assert re.match('', strOut), '%r != %r' %('', strOut)

        self.resetAllRepositories()

        built2, d2 = self.buildRecipe(self.recipestr2, "repoTrove")
        nvf2 = built2[0]
        nvf2 = nvf2[0], versions.VersionFromString(nvf2[1]), nvf2[2]

        built3, d3 = self.buildRecipe(self.recipestr3, "testTrove")
        nvf3 = built3[0]
        nvf3 = nvf3[0], versions.VersionFromString(nvf3[1]), nvf3[2]
        trv3 = repos.getTrove(*nvf3)

        self.assertEqual(str(trv3.requires),'\n'.join((
                    'file: /usr/bin/monodis',
                    'file: /usr/bin/smbunmount',
                    'file: /usr/share/dontResolve1',
                    'file: /usr/share/dontResolve2',
                    'trove: localTrove:runtime',
                    'trove: repoTrove:runtime')))


    def testCorruptGzipFiles(self):
        """
        """
        recipestr = """
class CorruptGzipFiles(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()

    def setup(r):
        r.addSource('compile_layout.dia', dir='/opt/foo/')
        r.addSource('process_tree.dia', dir='/opt/foo/')
"""
        # CNY-3377 -- build should succeed
        self.buildRecipe(recipestr, "CorruptGzipFiles")



class FilterExp(rephelp.RepositoryHelper):
    def testTuples(self):
        'Inclusion/exclusion by tuples must be filterExp tuples (CNY-3437)'
        recipestr = """
class TestFilter(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('/foo')
        r.Config(inclusions=('/foo', None, stat.S_IFDIR))
        r.Create('/etc/bar')
        r.Config(exceptions=('/etc/bar', None, stat.S_IFDIR))
        r.ComponentSpec('runtime', '.*')
"""
        trv = self.build(recipestr, "TestFilter")
        repos = self.openRepository()
        checked = 0
        for pathId, path, fileId, version, fileObj in repos.iterFilesInTrove(
                trv.getName(), trv.getVersion(), trv.getFlavor(),
                withFiles=True):
            if path == '/foo':
                self.assertEqual(fileObj.flags.isConfig(), True)
                checked += 1
            elif path == '/etc/bar':
                self.assertEqual(fileObj.flags.isConfig(), False)
                checked += 1
        self.assertEqual(checked, 2)

class Properties(rephelp.RepositoryHelper):
    def testProperties(self):
        'troveInfo for config descriptors (CNY-3571)'
        recipestr = """
class TestProperties(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(prefix)s/lib/iconfig/properties/username.iprop',
                 contents='''<descriptor>
<metadata>
    <displayName>stuff</displayName>
</metadata>
<dataFields>
    <field>
        <name>username</name>
        <descriptions>
            <desc>User Name</desc>
        </descriptions>
        <type>str</type>
        <constraints>
            <descriptions>
                <desc>Field must contain between 1 and 32 characters</desc>
            </descriptions>
            <length>32</length>
        </constraints>
        <required>true</required>
    </field>
</dataFields>
</descriptor>
''')
        r.Create('%(prefix)s/lib/iconfig/properties/proxy.iprop',
                 contents='''<descriptor>
<metadata>
    <displayName>stuff2</displayName>
</metadata>
<dataFields>
    <field>
        <name>proxy</name>

        <descriptions>
            <desc>Proxy</desc>
        </descriptions>
        <type>str</type>
        <default>foo.example.com</default>
        <constraints>
            <descriptions>
                <desc>Field must contain between 1 and 32 characters</desc>
            </descriptions>
            <length>32</length>
        </constraints>
        <required>true</required>
    </field>
</dataFields>
</descriptor>
''')
"""
        trv = self.build(recipestr, "TestProperties")

        props = {}
        for prop in trv.troveInfo.properties.iter():
            et = etree.fromstring(prop.definition())
            props.update([ (x.find('name').text, x)
                for x in et.find('dataFields').findall('field') ])

        self.assertEqual(sorted(props.keys()), ['proxy', 'username'])
        self.assertEqual(props['proxy'].find('default').text, 'foo.example.com')
        self.assertEqual(props['username'].find('default'), None)

        # now make sure that it got into the repository
        repos = self.openRepository()
        trv2 = repos.getTrove(trv.getName(), trv.getVersion(), trv.getFlavor())
        self.assertEqual(
            trv2.troveInfo.properties.freeze(),
            trv.troveInfo.properties.freeze())

    def testProperties2(self):
        recipeStr = """\
class TestProperties(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(prefix)s/bin/foo', mode=755)
        r.Properties(contents='''\
<descriptor>
<dataFields>
<field>
    <name>username</name>
    <type>str</type>
</field>
<field>
    <name>george</name>
    <type>str</type>
    <default>monkey</default>
</field>
</dataFields>
</descriptor>
''', package='%(name)s:runtime')
"""
        trv = self.build(recipeStr, "TestProperties")

        props = {}
        for prop in trv.troveInfo.properties.iter():
            self.assertEqual(prop.type(), 'sf')

            et = etree.fromstring(prop.definition())
            props.update([ (x.find('name').text, x)
                for x in et.find('dataFields').findall('field') ])

        self.assertEqual(sorted(props.keys()), ['george', 'username'])
        self.assertEqual(props['username'].find('default'), None)
        self.assertEqual(props['george'].find('default').text, 'monkey')

        # now make sure that it got into the repository
        repos = self.openRepository()
        trv2 = repos.getTrove(trv.getName(), trv.getVersion(), trv.getFlavor())
        self.assertEqual(
            trv2.troveInfo.properties.freeze(),
            trv.troveInfo.properties.freeze())

    def testProperties3(self):
        recipeStr = """\
class TestProperties(PackageRecipe):
    name = 'test'
    version = '0'
    clearBuildReqs()
    def setup(r):
        r.Create('%(prefix)s/bin/foo', mode=755)
        r.Properties('%(bindir)s/.*', contents='''\
<descriptor>
<dataFields>
    <field><name>username</name>
        <type>str</type>
    </field>
</dataFields>
</descriptor>''')
"""
        trv = self.build(recipeStr, "TestProperties")

        props = {}
        for prop in trv.troveInfo.properties.iter():
            self.assertEqual(prop.type(), 'sf')

            et = etree.fromstring(prop.definition())
            props.update([ (x.find('name').text, x)
                for x in et.find('dataFields').findall('field') ])

        self.assertEqual(sorted(props.keys()), ['username'])
        self.assertEqual(props['username'].find('default'), None)

        # now make sure that it got into the repository
        repos = self.openRepository()
        trv2 = repos.getTrove(trv.getName(), trv.getVersion(), trv.getFlavor())
        self.assertEqual(
            trv2.troveInfo.properties.freeze(),
            trv.troveInfo.properties.freeze())


def _findVendorPerl(_cached=[]):
    """Return the first vendor_perl directory for the system interpreter"""
    if not _cached:
        try:
            proc = subprocess.Popen("perl -le 'print foreach @INC'",
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    )
        except OSError:
            raise testhelp.SkipTestException(
                    "System perl not found or not operable")
        stdout, stderr = proc.communicate()
        if proc.returncode:
            raise testhelp.SkipTestException(
                    "System perl not found or not operable\n%s" % stderr)

        for path in stdout.splitlines():
            if path.endswith('/vendor_perl'):
                _cached[:] = [path]
                break
    if not _cached:
        raise RuntimeError("could not find vendor_perl")
    return _cached[0]
